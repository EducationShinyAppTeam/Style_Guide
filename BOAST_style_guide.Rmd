--- 
title: "Building Shiny Apps the BOAST Way"
subtitle: "A How To and Official Style Guide"
author: 
  - Neil Hatfield (njh5464@psu.edu) and Robert Carey (rpc5102@psu.edu)
date: "`r format(Sys.time(), '%d %B %Y')`"
site: bookdown::bookdown_site
output: bookdown::gitbook
documentclass: book
bibliography: [book.bib, packages.bib]
biblio-style: apalike
link-citations: yes
github-repo: educationshinyappteam/Style_Guide
description: "This is a manual for one approach to building Shiny Apps and serves as the official Style Guide for the Book of App for Statistics Teaching (BOAST)."
---

```{r, echo = FALSE, eval = FALSE}
# Required packages to build book
install.packages(c("bookdown", "devtools", "palmerpenguins", "psych", "rstatix"))

library(devtools)
devtools::install_github("rstudio/fontawesome")

# Required system library (pandoc-citeproc)
#  => https://pandoc.org/installing.html

# Rebuild book
bookdown::render_book("index.Rmd", "bookdown::gitbook")
```

# Welcome {-}

One of the biggest advantages of the modern era is computing power. This provides us with the ability to present statistical concepts in ways that allow students to explore and build their understandings in dynamic ways. A growing tool on this front are "Shiny Apps"--applications that may be run locally or on the web which are built using the the `R` language and the `shiny` package.

We are not the first group to build online applications to help students learn ideas, nor will we be the last. In fact, we're not even the first group to build Shiny apps for Statistics Education. Thus, there are many different approaches to how people go about designing and coding Shiny apps. The primary goal of this document is to lay out the approach that we use to 1) formalize the approach for ourselves, and 2) share our approach with others who are wanting to build their own Shiny apps for teaching.

This guide spells out the recommended approach for building and the required styling to be used for all apps included in the [Book of Apps for Statistics Teaching (BOAST)](https://github.com/EducationShinyAppTeam/BOAST). You will need to follow this Style Guide to ensure that any app you create meets (or exceeds) our standards and is worthy of inclusion in BOAST. 

__Effective Date: May 17, 2021__  
*All apps created and/or modified after the Effective Date are required to adhere to this version of the Style Guide. Apps which have not been modified since before the Effective Date will be brought into compliance on rolling basis.*

## Organization 

We've laid out this document into several parts, each with their own chapters.

+ Part 1: Getting Started
    - Chapter 1---Using a Workflow
    - Chapter 2---Explain Your Idea  
+ Part 2: Getting Ready to Code  
    - Chapter 3---Setting Up Your Computer  
    - Chapter 4---Exploring the Boast Template 
+ Part 3: Style Guide--Coding  
    - Chapter 5---General BOAST Coding Style
    - Chapter 6---Shiny (BOAST) Specific Coding Practices
    - Chapter 7---HTML and CSS
    - Chapter 8---Additional Coding Information
+ Part 4: Style Guide--App Layout
    - Chapter 9---General Layout
    - Chapter 10---Common/Reoccurring Elements
+ Part 5: Style Guide--Visual Style
    - Chapter 11---Color
    - Chapter 12---Static Images
    - Chapter 13---R Plots
+ Part 6: Style Guide--Language
    - Chapter 14--Wording
    - Chapter 15--Documentation
+ Part 7: Accessibility and Mobile Devices
    - Chapter 16--Accessibility
    - Chapter 17--Mobile Friendliness

Yes, this looks long but keep in mind the following:

<div style = "color: blue;">
+ Building an app is easy, but building an app that someone else can use effectively is a challenge. 

+ Building apps which support procedural conceptions is quick and easy to do. Building equitable apps which support users in developing productive meanings is much more difficult.
</div>

Our mission with BOAST is to achieve both with our entire collection. Thus, writing down all of the ins and outs of our process will take a significant amount of space.Whenever possible, we've attempted to provide you with examples where you can see our standards in action as well as code that you can use as templates. For each code block, you should be able to place your cursor over the block and see a copy icon in the upper-right hand corner. This will allow you to copy the code. We've also included links to additional resources so that you can learn more about key topics.

Keep in mind that this guide is a living document. As issues arise, we will update this guide to address them. Additionally, as we think of potential issues, we'll also update the guide to provide guidance before they occur. We welcome any suggestions for improvements.

## Why Our Approach?

There are many different reasons for why we've developed this particular approach. The most important of these reasons are 1) we're a team, 2) drawing upon research, 3) accessibility matters, and 4) a need to avoid the "shiny" problem. We will briefly discuss each one of these in turn.

### We're a Team of Developers

From the start, the [Book of Apps for Statistics Teaching (BOAST)](https://github.com/EducationShinyAppTeam/BOAST) has been the joint effort of faculty members and students. Having a clear articulation of how to make apps within our environment is critical to ensure that we have cohesiveness between the apps and through the years as the team changes. Our approach is meant to maximize the team's ability to adapt, maintain, and grow BOAST throughout the years. 

### Research Driven

We place a premium on drawing from what researchers have found about student thinking on various topics. And for those topics where the literature is thin or non-existent, we can fall back on the wealth of experience and expertise our faculty have. When we design apps, we focus on what the learning objectives are and work on how we might support students in developing meanings that are consistent with our targets.

### Accesiblity Minded

One of the key ways in which our approach differs from a vast majority of others is the level of accessibility thinking we go through. Shiny apps are __not__ very accessible by default and are extremely easy to make even more inaccessible. 

For example, consider the following entries in the [2020 Shiny app competition](https://blog.rstudio.com/2020/07/13/winners-of-the-2nd-shiny-contest/), as of 10/15/2020:

+ [Blog Explorer by Stefan Schliebs](https://nz-stefan.shinyapps.io/blog-explorer/#data): This Grand Prize winner has 11 accessibility errors, 68 contrast errors, and 14 accessibility alerts.
+ [Life of Pi: A Monte Carlo Simulation by Zauad Shahereer Abeer](https://shahreyar-abeer.shinyapps.io/life_of_pi/): This Honorable mention has 17 accessibility errors, 13 contrast errors, and 9 accessibility alerts.
+ [OTS Beta Dashboard by Mauricio Vargas](https://pachamaltese.shinyapps.io/tradestatistics/): This Honorable mention generates 14 accessibility errors, 0 contrast errors, and 5 accessibility alerts.
+ [Probability of Normal Distribution by Aep Hidayatuloh](https://azures.shinyapps.io/normdist/): Produces 5 accessibility errors, 108 contrast errors, and 27 accessibility alerts.
+ [Didactic Modeling Process: Linear Regression by Daniel Rivera](https://shiny.rstudio.com/gallery/didacting-modeling.html): while not part of the Shiny contest, this is a currently featured app in [RStudio's Shiny User Showcase](https://shiny.rstudio.com/gallery/), which has 57 accessibility errors, 26 contrast errors, and 184 accessibility alerts.

We used [WebAIM's Web Accessibility Evaluation Tool (WAVE)](https://wave.webaim.org/) to get these measurements. However, we must point out that the above numbers are *under-*estimates. The nature of a Shiny app interferes with WAVE's scanning tool (for example, non-displayed app pages aren't checked) as well as the fact that rendered R plots can only be checked for the presence of alt text/aria labels but not contrast errors, small font sizes, etc.

Now, this isn't to say that our apps are problem free. However, our process ensures that the number of errors that exist are in the single digits. When we publish an app, most of the remaining errors are ones we inherent from the `shiny` package and we're striving to address.

### Avoid the "Shiny" Problem 

In Education, and particularly in the American system, we wrestle with the "silver bullet problem". This problem is the belief that some reform effort will function as a fix or cure-all for the issues facing the education system. These reforms never bare out.

In design, people can get caught up with new (at least to them) tools such as a glitzy new system to do something. They will then start incorporating it everywhere they can. However, they often don't stop to think about whether this glittery new toy is appropriate or sound design. This is especially true for novice designers.

When dealing with Shiny apps for teaching, we face both problems simultaneously, which we call "The Shiny Problem". We work hard to ensure that 

1. Our apps aren't going to be viewed as silver bullets but as useful resources that can supplement instruction.
2. Just because `R` can do something doesn't automatically mean that we're going to include it; there must be a sound educational and pedagogical reason for including it.
3. Just because there's a fancy new package that's been released doesn't mean we'll blindly adopt it and use it wherever; there must be a sound educational and pedagogical reason.
4. Just because someone else made an app that did such-and-such doesn't mean we're going to; there must be a sound educational and pedagogical reason.

If you notice, ensuring that our apps are based in sound educational and pedagogical practices is key to our decision making. We strive for our Shiny apps to not become *shiny*.


We hope that this Welcome has helped you develop an image for the basis for many of the decisions that we've laid out in this guide. Feel free to move through the guide sequentially or to jump to various sections as needed. 

<!--chapter:end:index.Rmd-->

# Workflow {#workflow}

Before we get too far into designing, building, and maintaining BOAST apps, it is helpful to take a moment and talk about setting yourself up for success. One way to do this is through the notion of a workflow. In essence, you want to come up with a series of steps to follow. Writing this list out can provide you with something where you can take a step back and go "Wait. Where am I again? Oh yeah." This is particularly important as there will be times when you find yourself lost in coding and losing track of your broader goals.

We have two major workflows within BOAST: Revising existing apps and creating brand new apps.

Something to keep in mind with these workflows is that they are not strictly linear. That is, just because you have moved into Step 3, doesn't mean that you can't go back to Step 2 and make revisions. Additionally, as you get into Steps 5-8, you might find yourself coming back to Step 3 (and possibly Step 2) and making changes. This said, sketching out your plans will help you as you move forward with developing.

## Revising Existing Apps Worflow

1. Read the Style Guide.
2. Explore the existing apps in the [book](https://sites.psu.edu/shinyapps/) and their associated repositories on [GitHub](https://github.com/EducationShinyAppTeam).
3. When you identify an app you wish to work on,
    a. Go to that app's repository in [GitHub](https://github.com/EducationShinyAppTeam).
    b. Look through the `README.md` and the `DESCRIPTION` files (if present) so that you can get a sense of what the aims of the app are.
    c. Play with the app after going through 3b; ask yourself how the app demonstrates the aims. If the app doesn't, note this.
    d. Create new issues on GitHub to log both bugs and suggestions for improvements.
    e. Create an issue specifically if the App currently does not abide by this Style Guide.
    f. Optional---assign yourself to the issue.
4. Download the current version of the app by using either GitHub Desktop or RStudio.
5. Create a new branch for your developments.
6. Plan out your changes...ON PAPER.
7. Discuss your edits with others to get feedback and additional suggestions.
8. Begin editing the code.
9. As you edit, be sure to reference this Style Guide and test your code locally via Run App in RStudio.
10. Periodically push your edits to your development branch; don't forget to add commit messages and reference any issues.
11. When you're ready to do larger scale testing you'll need to publish your App to the TLT RStudio Connect server (see [Section \@ref(testing)](#testing)).
12. When you've reached a point where you've finished editing, push your most recent commit to your development branch and then create a Pull Request
    a. You will automatically get assigned at least one Reviewer (you will also be asked to review other people's code)
    b. Make any requested changes and re-push to your development branch
    c. Eventually, your code will get a final review before being formally approved.

If everything checks out, then we'll merge your development branch with the master branch and schedule formal deployment of your App.

## Creating New Apps Workflow

To see this workflow in action, check out [Chapter \@ref(makingApp)](#makingApp).

1. Read the Style Guide.
2. Identify a topic for your new App.
3. Sketch out your plans for the App...ON PAPER. __This should occur BEFORE you start coding.__ Be sure that you include:
    a. Suggested Full Title and Short Title
    b. Goal(s) of the app
    c. What will the user be doing (i.e., potential inputs)
    d. What will the user be experiencing (i.e., potential outputs), and
    e. Relationships between various elements.
4. When your plan __gets approval__, create a new repository on GitHub (see [Section \@ref(repo-naming)](#repo-naming)) using the App Template as the template for your new repository.
5. Begin writing the code.
6. As you edit, be sure to reference this Style Guide and test your code locally via Run App in RStudio.
7. When you get the basic structure of your App set up, push your code to GitHub and create a new development branch for your continued editing. You can open new issues on your app as you go.
8. Periodically push your edits to your development branch. Don't forget to add commit messages and reference any issues.
9. When you're ready to do larger scale testing you'll need to publish your App to the TLT RStudio Connect server (see [Section \@ref(testing)](#testing)).
10. When you've reached a point where you've finished editing, push your most recent commit to your development branch and then create a Pull Request.
    a. You will automatically get assigned at least one Reviewer (you will also be asked to review other people's code)
    b. Make any requested changes and re-push to your development branch
    c. Eventually, your code will get a final review before being formally approved.

If everything checks out, then we'll merge your development branch with the master branch and schedule formal deployment of your App.

### GitHub Repo Names {#repo-naming}

Each Shiny App has its own repository (repo) on GitHub. As you begin to create new apps, you'll have to create a new repo on GitHub for each one. The name of that repo is extremely important as this will play a critical role in establishing the URL for your App. To this end, you need to adhere to following guidelines:

+ Use [Title Case](https://en.wikipedia.org/wiki/Letter_case#Title_case) (not camelCase)
+ Use underscores ( _ ) instead of spaces
+ Match the App name as closely as possible
+ You have a 100 character limit

Be as descriptive as you can with your repo name; this will improve the indexing of your app.

While we can change repo names, doing so results in a large number of edits that have to be made. Thus, think carefully about how you are going to name your repository. 

If you come across a repo that is poorly named, please make an issue on the repo, and provide some suggestions for new names.

## Testing Your App {#testing}

To test your App beyond your local machine, we will be making use of TLT's RStudio Connect platform. You will need to follow these directions.

### Set Up/Login to the VPN

Please refer to the following PSU Knowledge Basis Articles:

+ [VPN for Windows](https://pennstate.service-now.com/sp?id=kb_article_view&sysparm_article=KB0013419)
+ [VPN for Mac OS 10.x](https://pennstate.service-now.com/sp?id=kb_article_view&sysparm_article=KB0013420)
+ [VPN for Mac OS 11.x](https://pennstate.service-now.com/sp?id=kb_article_view&sysparm_article=KB0016224)
+ [VPN for Linux OS](https://pennstate.service-now.com/sp?id=kb_article_view&sysparm_article=KB0013424)
+ [VPN for Apple iOS](https://pennstate.service-now.com/sp?id=kb_article_view&sysparm_article=KB0013422)
+ [VPN for Android](https://pennstate.service-now.com/sp?id=kb_article_view&sysparm_article=KB0013423)

You MUST be logged into the PSU VPN to both upload and test your App on each device.

### Connecting Your RStudio to TLT's RStudio Connect

You only need to do this step once.

1. After you've logged into the PSU VPN, go to [TLT's RStudio Connect](https://rstudio-connect.tlt.psu.edu:3939/connect) and log in using your PSU ID.
2. Once logged in, click on the Publish button as shown in the green box of [Figure \@ref(fig:testing1)](#fig:testing1)
```{r testing1, fig.cap="Click the Publish Button", fig.width=6, fig.height=4, echo=FALSE}
knitr::include_graphics("images/publish1.png")
```
3. Select Shiny App and a pop up window will appear.
4. Follow the steps in this window (especially Step 4) to set up the connection.

#### Checking You've Connected

You can check to see if you've connected by going into RStudio's Options and looking at the Publishing tab. You should see a similar entry as what is in the green box of [Figure \@ref(fig:testing2)](#fig:testing2):
```{r testing2, fig.cap="Check Your Publishing Profile", fig.align='center', fig.width=6, fig.height=4, echo=FALSE}
knitr::include_graphics("images/publish2.png")
```

### Publishing Your App for Testing

Make sure that you are connected to PSU's VPN and that you've already connected your RStudio to TLT's server. 

Click on the Publishing Icon, located just to the right of the Run App button. Be sure to select the TLT Server.

### Configuring for Testing

Once your App has been published, a new window should open in your browser that shows your App plus the optional controls. 

```{r testing3, fig.cap="Successful Publish and Settings", fig.align='center', fig.width=6, fig.height=4, echo=FALSE}
knitr::include_graphics("images/publish3.png")
```

In [Figure \@ref(fig:testing3)](#fig:testing3), you will need to change a setting to enable others (people and devices) to test your app. Click on the Access tab and set Who can view this application to Anyone-no login required. (These are highlighted in the green boxes.) Keep in mind that all users/devices MUST first connect to the PSU VPN to access your app.

We encourage you to add contributors as we did (orange box). Both Bob and I are the Go To people for tech issues and by adding us, you give us the ability to help you the best that we can. By adding us to the list of contributors on the TLT server, you will allow us to check the app's log files as well as any particular settings. Ultimately, this help us troubleshoot any difficulty you might encounter.

The most important piece is the Content URL (marked with the blue star). You'll need to copy this URL and give that URL out to your testers. This will allow them easily access your app, regardless of the type of device (e.g., computer, tablet, phone) they are using.

### Check the Logs

As you test your App, you'll want to look for any error messages and/or warnings that get generated. Click on the Logs tab (red box in [Figure \@ref(fig:testing3)](#fig:testing3)) to view.

### Problems?

If you run into problem either publishing your App or getting the App to launch on the TLT, please reach out to Neil and Bob. 

<!--chapter:end:01-workflow.Rmd-->

# (PART) Getting Started {-}

# Making an App {#makingApp}

Sooner or later, you'll reach the point where it is time to make your own Shiny App for BOAST. Approaching your App's construction in a systematic way will help you tremendously. The following suggested workflow is an abbreviated version of the one in [Chapter \@ref(workflow)](#workflow):

1. Read the Style Guide
2. Identify a topic
3. Sketch out your plans
4. Create a new repository on GitHub 
5. Begin writing the code
6. Edit and locally Test your code
7. Push your code to GitHub/Create a dev branch
8. Push your edits 
9. Larger scale testing
10. Pull Request
11. Additional tweaks

This workflow (both in the more expanded state and in the abbreviated one) leaves out a lot of the going-ons and decision making that goes into making an app. Our goal with this chapter is to walk you through this process as Neil makes an app from scratch.

## Step 1: Read the Style Guide {#step1}

This is step is critical to making an app that is easy to debug (vital when programming) and is in-alignment with the Standards that we have set for BOAST. Please take your time going through the Style Guide and keep an eye on it for updates. You can access the published Bookdown version by clicking on the address link located at the Guide's GitHub Repository.

As you build your App, we recommend periodically checking the Style Guide to 1) ensure that you're still adhering to it, 2) to stay up-to-date with the Guide, and 3) to see (and then use) any useful code chunks that are listed. Even as the authors of this Guide, we're constantly looking things up in the guide. Thus, there is no shame in constantly referring to the Style Guide; after all, it is meant to be *the* Go-To Reference.

*Note:* While we've written the following steps from the perspective of making a new app, what we describe equally applies to existing apps. Thus, you'll want to keep in mind both new and existing apps as you read through the remaining steps.

## Step 2: Identify a Topic {#step2}

This is one of the more challenging tasks for anyone: deciding what to make an app about. The notion of "picking a topic" is a bit misleading as not only should you pick a __topic__, but you also need to pick the __purpose__ of the app, and the __goals__. While all three go hand-in-hand with each other, the easiest decision of the three is purpose.

### Your App's Purpose {#step2a}

When we look across BOAST, we can categorize the apps into two major classes: apps whose purpose is to help students __learn__ an idea/concept and apps whose purpose is to help students __review__ an idea/concept. The [NHST Caveats App](https://psu-eberly.shinyapps.io/Significance_Testing_Caveats/) stands as a good example of an app whose purpose is to help students learn something. On the other hand, the [[Null] Hypothesis Testing Game (Tic-tac-toe)](https://psu-eberly.shinyapps.io/Hypothesis_Testing_Game/) and the [Matching Distributions](https://psu-eberly.shinyapps.io/Matching_Distributions/) are examples where the student is reviewing their understandings. There are some apps such as [ANCOVA](https://psu-eberly.shinyapps.io/ANCOVA/) that are dual purpose, having both learning elements and reviewing elements.

Generally speaking, apps whose purpose is __learning__ are going to have Explorations and possibly Challenges for Activity Tabs. Apps whose purpose is __reviewing__ will have just Games for Activity Tab(s).

By identifying early on the purpose of your App, you'll be able to better plan your app.

### The Topic {#step2b}

Here is where you'll decide what statistical idea/concept your App is going to be centered around. While you should be as specific as possible here, __apps for learning__ need to have much more specificity than __apps for reviewing__. Saying that you want your App "to deal with probability" is not going to be as useful as saying that you want your App "to help students recognize when probability is and is not appropriate for different contexts". 

Don't feel like you have to details down to the nanoscale from the start. As you continue developing and talking with people, you'll add in more details.

You can identify potential topics through any of the following:

+ Think of a concept in a Stat class that you (or your peers) struggled with (or still do)
+ Think of a concept where you thought to yourself "I wish there was a way to visualize this"
+ Think of a concept where you went "How does this work?"
+ Did you see/hear about a new study and thought to yourself "what's going on?"
+ Did a media report make you do a double take?
+ Ever think to yourself "I wish I had more practice with [topic]."
+ And more

Again, this list is just a starting place to identify potential topics. Draw inspiration from your experiences, your curiosity. Bounce ideas off of each other and the faculty. 

*__Word of Caution #1__*: While it is okay to get ideas from other websites, please keep track of this. We need to give credit where credit is due. If you come across an app (whether in Shiny or some other program) somewhere and you think that it would be good to translate that into Shiny app for BOAST, we need to know the original. 

*__Word of Caution #2__*: An unproductive place to begin is to say "Hey, I want to make a memory game" or "I saw this really cool animation and I want to make an app that does that." Both of these (especially the second) place the educational aspect of the app as a secondary focus. __This is not consistent with BOAST.__ All apps should place educational purposes and goals before anything else. Forcing a topic to make use of certain tool because that tool would be "cool" or "fun" does not further our goals.

### Goals {#step2c}

Now, we're sure that some people have already thought to themselves "hey, you've already had us identify purpose so isn't this the same?" To which we reply "No." We've used __purpose__ to refer an overarching aim of your App. Here, __goal__ refers to a much more contextualized aspect. While these goals will be less important for reviewing apps, you will need to identify specific learning goals for learning apps.

For this step, you're going to need to work with the faculty to identify the learning goals for your app. If you're drawing from a past experience in a course, look to see if there were learning objectives listed. Those can be extremely useful starting places.

### Example

*The following is a somewhat stream-of-consciousness narrative of how Neil tackled this step. We'll place flags in parentheses.*

I would like to make an app that would help introductory students __(*identifies an intended audience*)__ wrestling with some of the concepts of descriptive/incisive statistics __(*Purpose: learning*)__. Some ideas that I have are:

+ Conceptualizing the two distinct uses of the *sample arithmetic mean*--mitigation of measurement errors of a single object vs. measuring how well a group of objects/beings performs
+ Conceptualizing statistics as functions that measure attributes of collections
+ Conceptualizing the relationship between the values of the *sample median* and *sample arithmetic mean* is not a competition, that is, one is not "better than" the other
+ Avoid falling into the skewness trap for the ordering of the values of the *sample median* and *sample arithmetic mean*.

This last option feels like a fairly straightforward (and simple) app to create. Additionally, there's an [article by von Hippel on this issue](http://jse.amstat.org/v13n2/vonhippel.html) I can reference. __(*Topic: relationship between the values of *sample median *and* sample arithmetic mean *in the presence of skewness*)__

After using the app, a student should recognize that while for a many data collections that have skewness, the value of the *sample arithmetic mean* will be either greater (for positive skew) or less (for negative skew) than the value of the *sample median*, this is not an absolute rule. __(*Learning Goal*)__ In other words, just because a histogram shows positive skewness doesn't automatically mean that the value of the *sample arithmetic mean* is actually greater than the value of the *sample median*.

## Step 3: Sketch out plans {#step3}

In both workflows of [Chapter \@ref(workflow)](#workflow), there was the phrase "ON PAPER". Step 3 is where you need to take this phrase seriously.

To assist you, use the following layout by copying into a Word program (you can fit four on a landscape oriented page) and printing OR by sketching your version on paper:

```{r blankSketchLayout, fig.cap="Blank layout for sketching your ideas", echo=FALSE, fig.align='center'}
library(ggplot2)
library(emojifont)
ggplot(data = data.frame(x = rep(0, 50))) +
  geom_hline(mapping = aes(yintercept = 90), color = "black") +
  geom_vline(mapping = aes(xintercept = 50), color = "black") +
  scale_y_continuous(limits = c(0,100), expand = expansion(mult = 0, add = 0)) +
  scale_x_continuous(limits = c(0, 300), expand = expansion(mult = 0, add = 0)) +
  geom_text(mapping = aes(x = 56, y = 95, label = fontawesome("fa-bars")), family = "fontawesome-webfont", color = "black", size = 5) +
  geom_text(mapping = aes(x = 270, y = 95, label = fontawesome("fa-info")), family = "fontawesome-webfont", color = "black", size = 6) +
  geom_text(mapping = aes(x = 280, y = 95, label = fontawesome("fa-comments")), family = "fontawesome-webfont", color = "black", size = 6) +
  geom_text(mapping = aes(x = 292, y = 95, label = fontawesome("fa-home")), family = "fontawesome-webfont", color = "black", size = 6) +
  theme_void() +
  theme(
    panel.border = element_rect(color = "black", fill = NA, size = 2)
  )

```

Figure \@ref(fig:blankSketchLayout) gives you a BOAST app canvas upon which you can sketch your ideas. You can copy this image into any number of programs for printing or digitally editing. In the examples below, you'll see a hand-drawn version of this layout.

We want to stress just how useful sketching your ideas is. Neil routinely makes use of sketches whenever he builds apps for BOAST (e.g., the [Hasse Diagram App](https://psu-eberly.shinyapps.io/Hasse_Diagrams/)), for helping students working on BOAST apps (e.g., the [Data Table Examples app](https://rstudio-connect.tlt.psu.edu:3939/content/249) on the TLT server), or for his own projects (e.g., a [Mastery Based Grading Progress](https://rstudio-connect.tlt.psu.edu:3939/content/330) app also on the TLT server). Further, making sketches allows you to better share your ideas and will give you a goal for what to aim for as you actually begin to code.

### Key Elements

There are several things that you'll want to be sure that you include in your sketch:

+ A Suggested Title
    - This might not be what you settle on, but you'll need to have this firmed up by the time you get to Step 4.
    - You'll want to have both a [Long/Formal] Name and a shortened name ready.
+ Goal(s) of the App
    - Carry this forward from Step 2 as a tangible reminder.
    - If you have several goals, you might consider denoting which pages go with which goals.
+ What will the user be doing?
    - Thinking about what you want the user to do.
    - Identify anything the user might click on, drag, or otherwise manipulate.
    - If there are going to be options, identify what those options should be.
    - Will there be different levels?
    - Will there be a Challenge page?
+ What will the user experience?
    - Think about the general layout (explore, game, etc.).
    - What outputs should the user be examining?
+ What are the relationships between elements?
    - Think about how each input impacts the outputs.
    - If you want the user to have a certain experience, does the coding allow for that experience to happen?
+ Other Elements
    - Are you going to reference any external images?
    - Are you going to import any data files? If so, which ones? Do you have them?
    - Is there an activity packet?

The format of your sketches is up to you. 

### Example, cont.

As I start thinking about what this app might look like, I'm going to use a sheet of paper in quarters to organize some thoughts. Figure \@ref(fig:planSketchFull) shows the entire sheet of paper. The quadrants move left to right, top to bottom.

```{r planSketchFull, fig.align='center', echo=FALSE, fig.cap="Picture of My Plan", fig.width=5, fig.height=3}
knitr::include_graphics("images/planSketches/planSketch1.jpg")
```

In the first quadrant (Figure \@ref(fig:planSketchInfo)), I've listed a title ("Skewness's Impact on the Values of the *Sample Median* and *Sample Arithmetic Mean*"), a possible short title ("Skew, Med, SAM") as well as a restatement of my goal. I've then listed general aspects about the layout of my app, including what skin/theme color (yellow) I would need to use. 

I've additionally identified that I need to include the von Hippel article in my Reference Page as well as locating a version of the General Social Survey (GSS).

```{r planSketchInfo, fig.align='center', echo=FALSE, fig.cap="First Quadrant: General Information", fig.width=5, fig.height=3}
knitr::include_graphics("images/planSketches/planSketch2-Info.jpg")
```

The second quadrant of my paper is the Overview Page sketch (Figure \@ref(fig:planSketchOverview). I don't have much information here.

```{r planSketchOverview, fig.align='center', echo=FALSE, fig.cap="Second Quadrant: Overview Page", fig.width=5, fig.height=3}
knitr::include_graphics("images/planSketches/planSketch3-Overview.jpg")
```

```{r planSketchExplore, fig.align='center', echo=FALSE, fig.cap="Third Quadrant: Exploration Page", fig.width=5, fig.height=3}
knitr::include_graphics("images/planSketches/planSketch4-Explore.jpg")
```

The next quadrant (Figure \@ref(fig:planSketchExplore)) is where I started detailing the first Activity Page of my app: the first Exploration. I'm imagining that in this exploration that the user would look through a variety of cases where the "rule" does and does not work. What I want the user to walk away from this page is that just because a histogram looks positively skewed does not imply that the value of the *sample arithmetic mean* is greater than the value of the *sample median*. 

I'm imagining a drop-down menu that would allow the user to move through a variety of data sets. Ideally, these data sets would be real data. The General Social Survey, has a variety of attributes that we could use, include several that demonstrate what I want. For example, the number of adults (18+ y.o.) living in a household is positively skewed but the value of the *sample median* is larger than than the value of the *sample arithmetic mean*. Which each choice of the user makes, the histogram on the right will update to show the appropriate data, plus reference lines for the values of the two statistics. I might want to add a numerical display as well. I also want there to be some context helping the user to understand each choice.

I've left as an open question whether to enable a user to import/create their own data set on this page. I'm currently leaning towards not allowing this. Additionally, I've marked something for a punchline but this will need more thought.

```{r planSketchChallenge, fig.align='center', echo=FALSE, fig.cap="Fourth Quadrant: Challenge Page", fig.width=5, fig.height=3}
knitr::include_graphics("images/planSketches/planSketch5-Challenge.jpg")
```

The fourth and final quadrant (Figure \@ref(fig:planSketchChallenge)) is an idea I'm still kicking around. This would depend on the specific audience and course goals for which users would go here. My idea is to extend the goal for the app to allow students to construct an understanding for what conditions might lead to \(Sample\;Median\left(\mathcal{X}\right)<SAM\left(\mathcal{X}\right)\), \(Sample\;Median\left(\mathcal{X}\right)=SAM\left(\mathcal{X}\right)\), and \(Sample\;Median\left(\mathcal{X}\right)>SAM\left(\mathcal{X}\right)\).

At this moment, I'm leaning towards marking the Challenge Page as being a future improvement/addition rather than being part of the initial version of the app.

### Share Your Plan

Once you have a sketch, you'll want to share this plan with others to get ideas for suggestions, modifications, etc. Different people might be able to point you to code snippets you can reuse from other apps. More importantly, they might be able to help you think about things that you glossed over/missed and/or thought about but didn't articulate. By sharing these plans, we'll make better apps.

This is also the point in time in which the faculty will say whether you can go ahead and move to Step 4.

## Step 4: Create Repository {#step4}

Here you'll want to reference Section \@ref(repo-naming) on GitHub Repo Naming. You'll need to make sure that there isn't already a repository that has that name. When you get a name figured out for the repository, you can go ahead and create the repo.

Be sure to use the App Template as the template for your new repository.

Make sure to set Git Ignore to `R`.

For the example, check out the [Rethinking Sample Median vs Sample Arithmetic Mean Repo](https://github.com/EducationShinyAppTeam/Rethinking_Sample_Median_vs_Sample_Arithmetic_Mean/tree/development). The repo name is 50 characters long (including the underscores), gets at the goal of the app, and was not already in use.

## Steps 5-8: Write, Edit, Test, Debug {#steps5-8}

I have not had the time to return to the *Rethinking* app for the purposes of this chapter. I ended up shifting to work on both the Hasse Diagram app as well as the Mastery Grading Progress apps. In both cases, I started with paper sketches for what I wanted and as I started coding to make the apps come to life, I needed to make changes. However, the paper sketches became an anchor that helped me stay focused on what I was doing.

For the Hasse Diagram app, I'm sharing two images so that you can get a sense of the changes that occurred during the process. Be sure to check out the [Hasse Diagram App](https://psu-eberly.shinyapps.io/Hasse_Diagrams/).

```{r hasseSketch, fig.align='center', echo=FALSE, fig.cap="Hasse Diagram App Sketches", fig.width=5, fig.height=3}
knitr::include_graphics("images/planSketches/hasseSketch.jpg")
```

In addition to the sketches which help with designing the visual appearance, you can also sketch out important coding aspects:

```{r hasseNotes, fig.align='center', echo=FALSE, fig.cap="Hasse Diagram App Coding Notes", fig.width=3, fig.height=5, }
knitr::include_graphics("images/planSketches/hasseNotes.jpg")
```

(Please pardon the fuzzy nature of the photograph in Figure \@ref(fig:hasseNotes).) Figure \@ref(fig:hasseNotes) is the "sketch" of important actions that need to happen in the Hasse Diagram app: from resetting a page to navigation, from tab specific actions to objects that persist across the various tabs. Ultimately, this sketch became a useful To Do list as built the app. I must stress that you're seeing the final product. I built up this page as I went, I did not start out with this page filled out as you see here.


## Step 9: Larger Scale Testing {#step9}

Once you've built your app and you've done some initial debugging on your own machine, you then need to test your app on a larger scale. This is when you'll want to publish your app on the [TLT Server](#testing).

This is where you can get important feedback from people actually trying to use your app. This can help you improve the user interface as well as any behind the scenes coding that might be an issue. 

A common issue that occurs with Games is that when multiple people are playing the game, their game sessions might interact with each other. For example, one person might suddenly gain/lose points because of the actions of another player. This type of issue would only show up on servers when you have several people using the app at the same time. Make sure that during your testing, you try to have several people use the app at the same time.

## Steps 10-11: Pull Requests and Tweaks {#steps10-11}

Once you get to a certain point, you'll want to make a Pull Request on GitHub. This will trigger a review process for your code.

There are two parts to the Review Process: Appearance Review and Coding Review.

### Appearance Review (part of Large Scale Testing)

You'll need to post the TLT link to a common forum where you'll receive feedback in terms of testing and design. You'll want to attend to any feedback you get through this process. Faculty members will typically send you either an email with proposed changes or provide verbal feedback during a meeting.

### Coding Review

At least one other student team member will need to look through your code and make sure that 1) the code follows this Style Guide, 2) your app actually works, 3) any improvements that could still be made (including spelling and grammar). Each reviewer will need to leave their feedback as well as decision on GitHub. (The most common decision is "Request Changes".) 

Once you get their feedback, you'll need to do what you can to implement those changes. Once you've done so, push your updates and let the reviewer know. They will then need to perform a second review. If everything checks out, they will mark "Approve" as the decision.

Once your Pull Request has been approved by your peers, there is one last review: a quality control check by a faculty member (typically Neil). This check will look at your coding and the appearance. Feedback and a decision will be posted on GitHub. 

After all of the issues have been taken care of, Neil and/or Bob will merge your development branch into the main branch of the repo and will then deploy the app to the world. 

__CAUTION:__ if you ever see a "Merge" button, do not click on this button. Please let Neil and Bob be the only ones who click this button.

<!--chapter:end:02-makingAnApp.Rmd-->

# (PART) Getting Ready to Code {-}

# The Basics {#basics}

Before you get too far into this Guide and building apps, we would like for you to take a moment and ensure that you have the following tools at your disposal. This will help you start on a path to success.

## Getting Started Checklist {#checklist}

1. Ensure that you have all of necessary accounts and if not, put in a request to Bob ([rpc5102](mailto:rpc5102@psu.edu)).  
    a. [GitHub](https://github.com/)  
    b. [EducationShinyAppTeam](https://github.com/EducationShinyAppTeam) 
    c. [BOAST](https://teams.microsoft.com/l/team/19%3a8423bc25992a4451952d8312b497324d%40thread.skype/conversations?groupId=a83c9d1b-6bcc-46f4-aa25-82b2fad862ec&tenantId=7cf48d45-3ddb-4389-a9c1-c115526eb52e) in Microsoft Teams (tied to your PSU AccessID)
2. Ensure that you have all of the required software  
    a. [`R` (version 4.0.5 minimum)](https://cloud.r-project.org/) 
        - You can check your current version by starting `R` and seeing what version is listed at the start or by typing `version` into the console
    b. [RStudio Desktop (version 1.4 or higher; most current version preferred)](https://rstudio.com/products/rstudio/download/#download)
    c. [GitHub Desktop](https://desktop.github.com/)
3. `R` Packages from CRAN--here are some basic packages that everyone will need; be sure to install their dependencies. You may copy the following code into your R console to install the packages.

```{r packageInstall, echo = TRUE, eval = FALSE}
install.packages(
    pkgs = c("devtools", "tidyverse", "shiny", "shinyBS", 
             "shinydashboard", "shinyWidgets")
)
```

4. The `boastUtils` Package ([see below](#boastUtils))
5. The BOAST App Template ([see below](#templateApp))

## `boastUtils` Package{#boastUtils}

Bob created the [boastUtils](https://github.com/EducationShinyAppTeam/boastUtils) package to automate much of the design and development process. This will not only reduce the amount of work you'll need to do, it'll also make apps more consistent. Additionally, we routinely add tools to this package that are indispensable for creating and maintaining BOAST apps.
 
__Since Summer 2020, we require all apps to make use of this package.__

Please check out the [package's GitHub page](https://github.com/EducationShinyAppTeam/boastUtils) for instructions on installing and usage. You may also copy the following code into your R console to install the `boastUtils` package.

```{r utilInstall, echo = TRUE, eval = FALSE}
library(devtools)
devtools::install_github("EducationShinyAppTeam/boastUtils")
```

## A Quick Note on Packages (and R)

All too often, people will install R and R packages and that is the end of it. However, both are living things: they change over time. To this end, we encourage you to get into the habit of checking for updates to R and packages on a regular basis (e.g., monthly). (You can also do the same with RStudio.) This will ensure that you are using the newest version of packages which can help mitagate errors.

For updating R, you can type `version` in your R console to see what version you have and then compare that to current version posted to [CRAN](https://cran.r-project.org/).

For checking for updates to R packages that are on CRAN, click on the Update button of RStudio's packages window. (Typically found in the lower right quadrant.) You can also type `update.packages()` into your R console to run a check and then update packages. (You can also use `old.packages()` to see if you have any packages that have newer versions available.)

To update `boastUtils` you'll have to run the install command again. 

## BOAST Template App{#templateApp}

Bob and Neil have created a App_Template repository that you can use as a template for your own apps. To get started, clone the [App\_Template](https://github.com/EducationShinyAppTeam/App_Template) template repo found on GitHub. This will provide you with a skeleton for organizing your files as well as your code.

There are several methods you can use:

- [Direct Download (Basic)](#direct-download)
- [GitHub Desktop (Recommended)](#github-desktop)
- [Command Line (Advanced)](#command-line)
- [RStudio Project](#rstudio-project)

### Direct Download

You can download this repository directly by visiting:

> <https://github.com/EducationShinyAppTeam/App_Template/archive/master.zip>

### GitHub Desktop (STRONGLY RECOMMENDED)

If you are using [GitHub Desktop](https://desktop.github.com/) and have [linked your account](https://help.github.com/en/desktop/getting-started-with-github-desktop/authenticating-to-github) that has access to the [EducationShinyAppTeam](https://github.com/EducationShinyAppTeam) repository, you can do the following from inside GitHub Desktop:  

1. Bring up the Clone Repository Menu (File -> Clone Repository...)  
2. Enter App\_Template in the search bar and select the option that says App\_Template
3. Click the Choose... button for the local path (this is where you want to the clone to live on your computer)
4. Click the Clone button.

**See also:**

- [GitHub Desktop Help](https://help.github.com/en/desktop)


### Command Line

Enter the following command in your terminal:

```{bash, eval = FALSE}
git clone git@github.com:EducationShinyAppTeam/App_Template.git
```

**See also:**

- [Git Handbook](https://guides.github.com/introduction/git-handbook/)
- [Resources to learn Git](https://try.github.io/)
- [Happy Git and GitHub for the userR](https://happygitwithr.com/)

### RStudio Project {#rstudio-project}

You can also use RStudio to connect to and copy repositories from GitHub. There are a few extra steps that you'll need to go through compared to other methods. We recommend that you use GitHub Desktop.

1. In your browser, navigate to the repository you want to copy; in this case the [App\_Template repo](https://github.com/EducationShinyAppTeam/App_Template).
2. Launch RStudio and create a new project.
3. Select the Version Control option and then Git.
4. Switch back to your browser and click on the Clone or Download button. Click on the SSH, and then you should see a line of text starting with `git@github` that you can copy. Do so.
5. Returning to RStudio, paste the text you just copied into the Repository URL field.
6. Adjust the directory name and the subdirectory (where this project will live on your machine) as you see fit.
7. Click the Create Project button.

This method will ensure that you will be able to successfully push and pull changes to GitHub. For additional help, Neil has created a video "[Using RStudio to Connect to GitHub](https://youtu.be/IK0SiEz5vjs)" which walks you through the process.

## Useful RStudio Settings

There are a few settings in RStudio that can help make life much easier. While they aren't required, we do encourage you to at least try them out.

### Coding Margin

Generally speaking, you do not want your code to be on an overly long line. A cutoff of 80 characters works in the vast majority of cases. When your line gets beyond 80 characters, the entire line becomes much more difficult for people to read, including yourself. RStudio has the ability to add a thin grey line at the right hand side of your coding window to mark when 80 characters occurs.

To enable this feature:

1) Enter the Global Options of RStudio (see the Tools menu),
2) Click on Code in the left-hand menu,
3) Select the Display tab across the top,
4) Click the box next to "Show margin" and make sure that the Margin column field is set to 80,
5) Click Apply and OK

### Line Numbers

In the event that you RStudio does not automatically display line numbers for your code, you'll want to enable their display. This is vital for looking at error messages or discussing code with others.

1) Enter the Global Options of RStudio (see the Tools menu),
2) Click on Code in the left-hand menu,
3) Select the Display tab across the top,
4) Click the box next to "Show line numbers", 
5) Click Apply and OK

### Whitespace Characters

This option takes a bit of getting used to. In essence, RStudio will display a "whitespace" character (e.g., a grey dot) in each bit of empty space as well as end of line characters (a grey dash with a downwards hook at the right-hand end). This option can help you make sure that you are improving the readability of your code by using appropriate spacing.

1) Enter the Global Options of RStudio (see the Tools menu),
2) Click on Code in the left-hand menu,
3) Select the Display tab across the top,
4) Click the box next to "Show whitespace characters", 
5) Click Apply and OK

### Rainbow Parentheses

One of the most common programming bugs is that of mismatched parentheses (), braces {}, or brackets []. RStudio can help out with this through the use of Rainbow Parentheses, which makes color matched sets of parentheses as well as automatically putting in both open and close versions.

1) Enter the Global Options of RStudio (see the Tools menu),
2) Click on Code in the left-hand menu,
3) From the Editing tab, make sure that "Insert matching parens/quotes" is checked,
3) Select the Display tab across the top,
4) Click the box next to "Rainbow parentheses", 
5) Click Apply and OK

### Code Diagnostics

Two useful Coding Diagnostics deal with the assignment operator, `<-` and the putting the appropriate whitespace into your code. RStudio has tools to help you ensure that you adhere to the proper usages here.

1) Enter the Global Options of RStudio (see the Tools menu),
2) Click on Code in the left-hand menu,
3) Select the Diagnostics tab across the top,
4) Make sure there is a checkmark in the boxes next to each of the following
    + Show diagnostics for R
    + Enable diagnostics within R function calls
    + Check arguments to R function calls
    + Check usage of '<-' in function calls
    + Provide R style diagnostics (e.g. whitespace)
5) Click Apply and OK

You may select other diagnostics in addition to those we've listed here.

<!--chapter:end:03-setup.Rmd-->

# The Exploring the BOAST Template {#template}

Now that you've gotten your computer set up and you've made yourself a workflow, you're nearly ready to begin working on apps for BOAST. This Guide is the primary key to getting started but the BOAST Template is the secondary key to your success. 

## Structure of the BOAST Template Repository {#templateRepo}

To get started, you'll want to take a look at the [BOAST App Template Repository](https://github.com/EducationShinyAppTeam/App_Template) either online or clone the repository ("repo") to your computer. There are several key items in the repo that you'll need to be aware of:

+ `app.R`: this is where you will write the code for your app.
    - Note: Older apps (i.e., non-compliant with this Style Guide) might have `ui.R` and `server.R` files instead. You'll need to convert them if you are doing an update.
+ `www` folder: this will be where you store image files and other non-data, non-R files for your app.
+ `docs` folder: this is where several key files are stored for your including the License, a Readme, and a screenshot.
+ `DESCRIPTION`: this file is where you'll need to place some key information about your app
+ Additional files and folders you may ignore: `.git`, `.gitignore`, `.lintr`.

As you build your app (or work with existing apps), you'll add various files to the repo. For some of the older apps, part of the maintainer's job will be move the repo into alignment with this template (i.e., add anything missing and move files around as needed). However, the basics of the App Template are required elements for all apps; thus, you need to familiarize yourself with them.

We will now briefly discuss the files which you will be editing.

## The `app.R`  File{#appR}

This is where you'll do the vast majority of your work. We will not spend too much time describing the ins and outs of this file at this time. However, we do want to mention the five components to any BOAST app.R file.

1. __Loading Packages:__ the first part of any `app.R` file will be where you load all necessary packages for your app through a series of `library` calls. Only load those packages that you are actively using. 

    For example, if you only need `ggplot2`, include `library(ggplot2)` in the list rather than loading all of the the Tidyverse (i.e., `library(tidyverse)`). 

2. __Global Constants, Functions, and Data Sets:__ after you load all needed packages, you can now define any constants, custom functions, and data files. We call these elements "global" as by defining them here, you may call them any where in your code. If you were to only define them in the server section, then you can only call on them while you're in the server. Additionally, by defining them here, you allow for better resource sharing when we deploy your app and you start having hundreds of users.

3. __The User Interface (UI):__ this next portion is where you will define all of the elements that will make up the user interface. The App Template will provide you with a skeleton, but it is up to you to make your sketches come to life.

4. __The Server:__ after you create the UI, you now have to create the server which is where you'll define actions for your app. This is where you'll make use of any inputs or buttons you created in the UI to make things happen such as causing events to occur, plots to appear/change, score user's answers, etc.

5. __The BOAST App Call:__ the final line of your code will be the BOAST app call (`boastUtils::boastApp(ui = ui, server= server)`). This is the line of code which takes your UI and server definitions and actually creates your app.

## DESCRIPTION {#description}

The DESCRIPTION file plays the role of metadata for your app. Formerly, we used to store some metadata inside of the apps. However, as our needs for managing app metadata have grown, we've gone a different route. Enter the DESCRIPTION file. If an existing app does not have a DESCRIPTION file, copy the DESCRIPTION file from the App Template and place that copy in the existing app's repo. Then edit the file. Be sure to push your changes to GitHub when finished.

The DESCRIPTION contains several fields (typically, the first word of each line, to the left of a colon). You will be editing the following fields:

+ __Title:__ this is where you'll put the full title of your app.
+ __ShortName:__ this is where you'll put the short version of your app's title (you'll also use this in your app's header.)
+ __Date:__ this should reflect the date of the submission that was approved for deployment.
+ __Lifecycle:__ you'll put the one word mention of the lifecycle which will match what you place in the README; see [below](#lifecycle) for the words to put here.
+ __Authors:__ this is where you'll put information about who worked on the app; more on this [below](#authors).
+ __Chapter:__ this will be the primary chapter of BOAST where the app will live; e.g., Chapter 2.
+ __Description:__ you'll enter the description of the app here.
+ __LearningObjectives:__ you'll list all learning objectives for your app here; more details [below](#learningObjectives).
+ __BugReports:__ Replace `Sample_App` with your app's GitHub repo name
+ __Tags:__ list out all of the tags that go with your app; see [below](#tags).

### Authors

This is where you'll list each person who is involved with your app. You'll want to follow the two examples provided for how to add each person. Each person will get their own `person` call, on a line that is indented four (4) spaces.

Within each person call, you'll need to provide their given (first) name, their family (last) name, their email, and their roles. Notice that you can give a person more than one role. Here is a brief explanation for the roles you can use:

+ __"aut"__ is for individuals who made substantial contributes to the app and should be include in any citations, i.e., they are authors of the app
+ __"cre"__ is for individuals who originally came up with the app; i.e., the original creators
+ __"ctb"__ is for individuals who contributed to the app in some way but those contributions are smaller than an author's
+ __"fnd"__ (RARE) if we receive additional funding from someone to create a specific app, we will list then as funder with this role

### Learning Objectives{#learningObjectives}

Each app will have one or more learning objectives. This information will be made available to instructors through the Instructor's App and is important for deciding whether to use the app. You will not have to come up with the wording of these objectives on your own. Rather the faculty will assist you. 

Each objective will be entered as a character string enclosed in double quotation marks and indented four (4) spaces. If the description is rather long, simply break the line and continue. You'll place a comma between objectives.

### Tags

The Tags portion is where you'll enter all of the appropriate tags we use in BOAST (i.e., Simulation, Multilevel, Real Data, Game) for your app. As we go through the apps and create new ones, we might come up with new tags which we can then apply to the apps.

## README.md {#readme}

The `README.md` file is a fairly simple file which only contains four items:

1) The app's [Full] Title
2) The app's badges
3) A link to a current screenshot of the app
4) The app's description

Three of these items (title, screenshot, and description) are self-explanatory. We will quickly mention that you will need to insure that you use the appropriate Title and Description not only here in the `README.md` but also in `DESCRIPTION`. You'll also need to use the full title inside the `app.R`.

### Badges

The second element of the `README.md` are the badges. These allow viewers to see (at a glance) some important information about the app. There are two main types of badges: lifecycle and year.

Beneath each explanation, we've included the code you would place in the `README.md` file to make that badge appear.


#### Lifecycle Badges {#lifecycle}

Lifecycle badges act as a signifier of where in the cycle of development your app is at. Each badge conveys a particular meaning for us. The word that you'll put in the Lifecycle field of the DESCRIPTION file will be in __bold__.

+ ![stable](https://img.shields.io/badge/lifecycle-stable-brightgreen) An app is considered __stable__ when we've reached a point where there are no bugs left to fix, only minimal improvements can be made, and adding new features is not necessary a priority. This is where we want most apps to end up.
    - `![stable](https://img.shields.io/badge/lifecycle-stable-brightgreen)`
<br /> <br />
+ ![maturing](https://img.shields.io/badge/lifecycle-maturing-blue) A __maturing__ app is one that is nearing stability but we're still in the process of fine tuning or adding new features to the app.
    - `![maturing](https://img.shields.io/badge/lifecycle-maturing-blue)`
<br /> <br />
+ ![experimental](https://img.shields.io/badge/lifecycle-experimental-orange) The __experimental__ badge is for two types of apps: ones that we are still in the process of developing and ones which we've recently released and are actively refining. The common element here is that these apps can change much more drastically than a mature or stable app will.
    - `![experimental](https://img.shields.io/badge/lifecycle-experimental-orange)`
<br /> <br />
+ ![questioning](https://img.shields.io/badge/lifecycle-questioning-yellow) Labeling an app with the __questioning__ badge is a sign that we have doubts that the app (in it's current state) meets the educational/pedagogical goals intended. These are apps where we need to make a decision about whether to update the app, create a new app, or retire the app.
    - `![questioning](https://img.shields.io/badge/lifecycle-questioning-yellow)`
<br /> <br />
+ ![superseded](https://img.shields.io/badge/lifecycle-superseded-orange) A __superseded__ app is one where we've made the decision to create a brand new app which will ultimately replace this one. The new app will have its own repository and will be treated as a brand new app rather than an update of this app. In time, a superseded app will be downgraded and retired.
    - `![superseded](https://img.shields.io/badge/lifecycle-superseded-orange)`
<br /> <br />
+ ![retired](https://img.shields.io/badge/lifecycle-retired-red) Once an app has reached a point where we have chosen to no longer actively maintain it and feel that it does not serve a pedagogical purpose, we retire the app (__retired__). This includes removing the app from our shinyapps.io server. The code will be saved on GitHub for posterity but no development will take place.
    - `![retired](https://img.shields.io/badge/lifecycle-retired-red)`

#### Year Badges

Year badges denote when the app was officially added to the BOAST shinyapps.io server (i.e., deployment). 

+ ![year](https://img.shields.io/badge/year-2018-lightgrey) Here the four digit year indicates in what calendar year we deployed the app.
    - `![year](https://img.shields.io/badge/year-YYYY-lightgrey)`
    - Replace YYYY with the appropriate year.
<br /> <br />
+ ![new](https://img.shields.io/badge/lifecycle-newapp-brightgreen) This signifies that the app has just recently been added to our shinyapps.io server for the first time. We will drop this badge after one year.
    - `![new](https://img.shields.io/badge/lifecycle-newapp-brightgreen)`

## screenshot.png {#screenshot}

You may see a file called `screenshot.png`. This is a placeholder file that adds a generic screenshot to the `readme.md`. After your app is deployed, we will update the `readme.md.` to link to the photo of your app used on the BOAST website. Thus, you do not have to do anything with this file.

<!--chapter:end:04-template.Rmd-->

# (PART) Style Guide-Coding {-}

# Coding Style {#coding}

Now that you've gone through the Getting Ready to Code chapters, we can turn our attention to the first portion of the Style Guide--Coding Style. 

## General Coding Style {#genCode}

Our Coding Style is based upon the [tidyverse style guide](https://style.tidyverse.org/). However, we make some important departures and have some additional practices that you will need to follow. 

When it comes to our Coding Style we strive to adhere to the following principles:

+ Make your code readable
+ Make your code efficient
+ Make your code readable
+ Be kind to future coders
+ Make your code readable

Yes, we realize that we stated "Make your code readable" three times. Readable code is the *__MOST__* important thing you can do. Even if you don't write the most efficient code, readable code will allow future students to examine your code and suggest improvements. Further, readable code will help you make sense of what *you* were trying to do when you come back to the app after several weeks or months. We will discuss all three of these principles in turn.

## Make Your Code Readable {#readable}

For us, making code readable boils down to three major aspects: formatting and spacing, naming, and being explicit. By way of an example, consider the following code:

```{r badCodeExample1, echo=TRUE, eval=FALSE}
# Bad Code Example
selectInput("input1","pick",listA,NULL,TRUE,FALSE,"80%",2)
```

Just looking at this code, do you have any idea what it does? Let's look at a BOAST version of this code:

```{r goodCodeExample1, echo=TRUE, eval=FALSE}
# Good Code Example
selectInput(
  inputId = "selectedPeople",
  label = "Select who to contact",
  choices = nameList,
  selected = NULL,
  multiple = TRUE,
  selectize = FALSE,
  width = "80%",
  size = 2
)
```

While the above code takes more lines, it is infinitely more readable. Both sets of code call the same function, `selectInput`, to create a dropdown menu where the user can select individuals. In the Bad example, the user has to either 1) have the order of arguments memorized, or 2) guess what each argument does. In the Good example, each argument is listed out by name (e.g., `inputId` and `multiple`). While you might not know what each of these arguments controls (yet), you can at least see what values are being passed to each one. Further, you know that the choices are stored in the `nameList`, which is a much clearer name than `listA`. 

### Formatting and Spacing {#formatSpace}

One of the most important aspects of making code readable is proper formatting and spacing. A common belief is that the fewer the lines of code, the better the program. However, what often happens when people attempt to follow this belief is that they wind up with indecipherable code...even to themselves. Thus, they violate not only our Readability principle but also our Be Kind principle. 

#### Line Length

With only a few exceptions (e.g., URLs), we want to keep each line to no more than 80 characters long. RStudio has a built-in tool to help you with this.

1. Click on the Tools menu and select Global Options...
2. Click on Code in the left menu that appears.
3. Along the top of the window for Code, find and click on Display.
4. Check the box for Show margin and ensure that 80 appears in the box labeled Margin column.
5. Click Apply and OK.

This will add a thin grey line to the editor window that marks where the 80 character limit occurs. While this won't force you to a new line, this will serve as visual cue to you that your code line is too long and you should press return to move to a new line.

If you only have a few characters left, then finishing the line and making a line just a few characters over 80 is acceptable. Just try to keep such exceptions few and far between.

#### Indentation

Indenting your code is a great way to help with readability. RStudio will automatically do this for you. In the Good Example above, each of the arguments was indented 2 spaces; this helps convey that they are nested inside the object that was less indented. 

You can (and will) have nested indentation, for example:
```{r goodCodeExample2, echo=TRUE, eval=FALSE}
# Example of Indentation
ui <- list(
  dashboardPage(
    dashboardHeader(
      # code omitted
    ),
    dashboardSidebar(
      # code omitted
    ),
    dashboardBody(
      tabItems(
        tabItem(
          tabName = "overview",
          # code omitted
        )
      )
    )
  )
)
```

We have several layers of indentation but by looking at the formatting, we can see which things are at which level and their relative ranks. For example, the Header, Sidebar, and Body are all at the same level (i.e., they are all aligned at the same indentation), while they are all subordinate to the Page and the user interface ("ui"). The tab called "overview" is part of the Body based on the indentation.

One benefit of proper formatting through indentation is that you can get a quick visual check of proper close parentheses with the nice cascade of close/right parentheses. When parentheses are directly on top of one another or have gaps between them, that is a good sign that you have not properly closed a section and could either encounter a fatal error (app crash) or display errors. RStudio 1.4 brings Rainbow Parentheses to help you visually match up grouping symbols (parentheses, square brackets, curly braces, etc.)

RStudio should automatically indent code for you as you write and press the return/enter key. In the event that a line gets off, or you want to double check indentation, there is a keyboard shortcut that allows you to re-indent the line your cursor is in given the line just above: for Macs press Command + i; for Windows press Control + i. Keep in mind that this shortcut works only on one line at a time and always references the line just above the one you're in.

#### Function Calls

To format function calls, we will want to type the name of the function and the immediately put a open/left parenthesis--`functionName(`--what happens next depends on what you're trying to do:

+ If the function takes/needs no arguments, then immediately type the close/right parenthesis, e.g., `copyrightInfo()`, and return to a new line.
+ If you can fit all of the arguments on that line without going beyond 80 characters, then you can do so. For example, `renderIcon(icon = "correct")`.
+ In all other cases, press the return/enter key to move to a new line which should automatically indent. Enter each argument name and value followed by a comma on their own line. After you've typed the last argument's value, omit the comma, return to a new line and put the close/right parenthesis. For example,
```{r goodCodeExample3, echo=TRUE, eval=FALSE}
# renderIcon has three arguments: icon, width, and html
output$markProb1 <- renderIcon(
  icon = ifelse(
    test = input$probVal1 == answer1,
    yes = "correct"
    no = ifelse(
      test = abs(input$probVal1 - answer1) <= 0.05,
      yes = "partial",
      no = "incorrect"
    )
  ),
  width = 60,
  html = TRUE
)
```

If you've set up RStudio to automatically create pairs of grouping symbols, the close/right parentheses should automatically format themselves when you return to new lines.

#### Assignment Operator

To store a value, define a function, etc., you need to use the assignment operator `<-`. In the above examples, you'll notice that we used this operator to create the UI (`ui <- list()`) and to create the grading mark (`output$markProb1 <- renderIcon()`). These are both appropriate usages of assignment. You should not use `=` in these cases.

You'll also notice that we used `=` with all of the argument names and their values. This is proper usage. You need to pass values to arguments through the `=` sign and not `<-`.

#### Spacing

Spacing (or whitespace) refers to the portions of your line where you don't put any characters. In the bad example above, there was no whitespace in the code; everything ran together. Spacing acts in code exactly like it does in written languages. Whileapersoncanreadasentencewithnospaces, the sentence is much easier to read when we use proper spacing. 

+ Put a space on both sides of `<-` and `=`.
+ Put a space after every comma, unless the comma ends a line.
+ Put a space after `if`, `else`, `else if`, and `for` (but not `ifelse`).
+ Put a space on both sides of comparison operators (e.g., `<`, `>=`, `!=`).
+ Put a space on both sides of mathematical operators (e.g., `+`, `*`, `^`, `%%`, `~`).
+ Put a space between the condition (what's in parentheses) for an `if`/`for`/`else if` and the open/left curly brace `{`, then return to a new line.
+ When closing a chunk of code with a curly brace, `}`, if you are moving into an `else` or `else if` chunk, place a space after the close brace and then type `else`. For example, `} else {` or `} else if (condition) {`. Otherwise, return to new line.

### Use Informative Names {#naming}

Use informative names for variables and functions in your code. Use names that give another person a sense of what that variable represents (nouns) or what the function is supposed to do (action verbs). For example,

- `scoreMatrix` is a matrix that holds a set of scores  
- `checkGame` is a function that checks the state of the current game

Use [camelCase](https://en.wikipedia.org/wiki/Camel_case) for variable names and functions. The first word begins with a lowercase letter and additional words start with Capital letters with no spaces or underscores ( \_ ) between them. (This is a departure from the tidyverse style.)  

Avoid using the variable names from code that you're making use of from another app or script. For example, don't use `waitTimes` to hold your data on the number of correct answers a user has given. It is also good practice to avoid re-using function names that appear in other libraries that are currently loaded to avoid [namespace collision](https://en.wikipedia.org/wiki/Naming_collision).

### Be Explicit {#explicit}

One of the best practices a coder can do is to be explicit. And no, we don't mean that type of explicit. This links back to [Informative Naming](#naming) but goes a step beyond. `R` is a functional programming language. One of the important aspects of this is that functions in `R` obey the same rules as mathematical functions, especially multivariate functions. 

#### Function Arguments

One implicit fact about functions that most students don't realize is that the order of a function's arguments are a matter of convention and is actually arbitrary. While we might define *f* as \(f(x,y) = x^2+3y\), we could call \(f(y=2,x=1)\) and get the same output as \(f(1,2)\) when we use the convention set up in the definition. This issue is exacerbated with functions in `R`.

Therefore, when you pass values to the arguments of a function in `R`, you should be explicit and include the argument name in your code. For example,

```{r explicit1, eval = FALSE}
bsButton(
  inputId = "submit",
  label = "Submit",
  color = "primary",
  style = "bordered",
  class = "btn-ttt"
)
```  

#### Function Definitions

When you are defining your own function, it is always a good idea to explicitly state what the function spits out. This is particularly important if your function uses any type of control logic. To denote what the function passes as the output, you use `return` as shown below:

```{r explictReturn, echo=TRUE, eval=FALSE}
collatz <- function(x, c = 1){
  if (x < 0 || x != round(x, digits = 0)) {
    return("Error: x must be a positive integer.")
  } else if (x == 1) {
    return(paste("You're at 1 in", c, "steps."))
  } else if (x %% 2 == 0) {
    return(collatz(x = x / 2, c = c + 1))
  } else {
    return(collatz(x = 3 * x + 1, c = c + 1))
  }
}
```

The `collatz` function above allows us to see the Collatz Conjecture in action (i.e., that starting with any positive integer, the sequence formed by taking half of an even value or 3 times an odd value plus 1 will always go to 1). The control logic is the series of `if, else if, else` statements.

Even if you store the outputs in an internal variable (see the `gradeProb` function in the [DRY Grading Example](#dryGrading)), you should still end your function definition with an explicit `return` call.

#### Why is being explicit important?

When you write explicit code, you not only improve your code's readability and are automatically being kind to future coders, but you're also guarding against certain forms of code breaking changes. When we build Shiny apps, we often call upon packages that other people have made. In those packages are functions that have a default ordering to them. For example, in one version of the package you might have `gradeThis(userInput, answerKey, partNumb)` but in the newest version you have `gradeThis(partNumb, userInput, answerKey)`. If you were not explicit by naming the arguments in calls of `gradeThis` updating the package will cause your app to break and throw errors.

Further, being explicit also reduces the number of message printed to the console. For example, in `ggplot2`, if you call `geom_smooth(method = lm, se = false)` your code will execute properly. However, you will get a message in the console to the effect that `geom_smooth` used `y ~ x`. You can suppress this message simply by adding `formula = y ~ x` to the `geom_smooth` argument list. (Anything that gets printed to the console fills up your app's log file. The more that's in the log file, the harder they are to use to debug your app if/when it crashes. Thus, we want to keep the console as quiet as possible.)

### Exceptions to Readability

There are few places where we make exceptions to the above formatting rules. These exceptions include the Dashboard Header and the Dashboard Sidebar. While we keep these lines readable, they follow a sightly different set of formatting to minimize their impact on the readability of the rest of the code. The App Template already has code in these sections for you to copy/paste for additional lines.

__If you are ever unsure about how readable your code is, all you have to do is ask someone else. This is a great place for using Peer Reviews can help all students involved wither their coding skills.__

## Make Your Code Efficient {#efficient}

> I would have written a shorter letter, but I did not have the time.
<div align="right">
> --- Blaise Pascal
</div>

Much like writing a short letter (paper or memo), writing efficient code takes time. Often coders first write *inefficient* code to translate their sketches into a working app. Then they can begin to make their code more efficient.

As you write more code, you'll get the hang of writing more efficient code from the start as well as seeing how to make existing code more efficient. Two ways that you can work towards efficient code is to practice DRY coding and to minimize your package usage.

### DRY Coding

DRY coding is the principle of Don't Repeat Yourself when coding. If you find yourself writing the same code several times, then you should DRY your code and look for a way to make things more efficient. There are several different situations where DRY might come into play. Here are just a few cases.

#### Reoccuring Elements 

Suppose that you use the same list of choices for several different inputs. Rather than retyping the list each time, define the list as an object (e.g, `nameList`) and then you can call that list in each of the inputs (e.g., `choices = nameList`).

#### Grading User Responses {#dryGrading}

Rather than retyping the grading logic several times, you can define a single function and then call that function. For example,

   ```{r dryCode1a, echo=TRUE, eval=FALSE}
   gradeProb <- function(user, answer, tolerance = 0.001, partial = 0.01){
     outcome <- list()
     if (abs(user - answer) <= tolerance) {
       outcome$feedback <- "You are correct."
       outcome$mark <- "correct"
     } else if (abs(user - answer) <= partial) {
       outcome$feedback <- "You are almost correct."
       outcome$mark <- "partial"
     } else {
       outcome$feedback <- "Please try again."
       outcome$mark <- "incorrect"
     }
     return(outcome)
   }
   ```

The `gradeProb` function defined above will grade a user's [probability] value (i.e., `user`) against the answer key (`answer`) and return a list of two items: a feedback statement and the scoring mark to pass along to `renderIcon`. The following code shows us using the `gradeProb` function to generate the necessary outputs.

```{r dryCode1b, echo=TRUE, eval=FALSE}
prob1 <- gradeProb(
  user = input$problem1,
  answer = answerKey[1]
  ## Omitting the remaining two arguments will use the default values
)
output$problem1Feedback <- renderUI({
  prob1$feedback
})

output$problem1Mark <- renderIcon(icon = prob1$mark)
```

#### Graphs

If you are building multiple graphs which have the same basic graph or are going to be updating the same basic graph by adding layers, then storing a base graph as an object is a good idea. For example,

  ```{r dryCode2, echo=TRUE, eval=FALSE}
  # Create a basic data frame that will cover the majority of your cases
  baseGraph <- ggplot(
    data = data.frame(
      x = -10:10,
      y = -10:10
    )
  ) +
    scale_x_continuous(expand = expansion(mult = 0, add = 1)) +
    scale_y_continuous(expand = expansion(mult = 0, add = 1)) +
    theme_bw() +
    theme(
      title = element_text(size = 18),
      text = element_text(size = 16)
    )
  ```

When we get to plotting our actual graphs, or updating the existing graph, we can call `baseGraph` and then add the elements we want, such as a scatter plot:

  ```{r dryCode3, echo=TRUE, eval=FALSE}
  plotData <- data.frame(
    heights = rnorm(n = 50, mean = 70, sd = 3.5),
    weights = rnorm(n = 50, mean = 100, sd = 8),
    sex = sample(x = c("M", "F", "I"), size = 50, replace = TRUE)
  )
  baseGraph +
    geom_point(
      data = plotData,
      mapping = aes(x = heights, y = weights, color = sex, shape = sex),
      size = 2
    ) +
    theme(
      legend.position = "right"
    ) +
    xlab("Height (in)") +
    ylab("Weight (kg)") +
    scale_color_discrete(
      name = "Sex",
      labels = c(
        "M" = "Male",
        "F" = "Female",
        "I" = "Intersex/Other"
      )
    ) +
    scale_shape_discrete(
      name = "Sex",
      labels = c(
        "M" = "Male",
        "F" = "Female",
        "I" = "Intersex/Other"
      )
    ) +
    labs(
      title = "Height and Weight by Sex"
    )
  ```

Notice that we continue building on our base plot, including passing new data into the plot, adding new theme elements, and labels as necessary. 

Another important feature of the above code is a __key accessibility feature__: combining color AND shape. Do not rely on just color alone as individuals who are color blind will struggle; always pair color usage with an additional aesthetic such as shape.

#### Repeating Yourself

There are many other cases where you might find yourself repeating. These are good cases for DRY-ing your code through the use of defining a new object/variable or a function. 

#### Over DRY-ing Code

When you are building an app, there will be a certain amount of repetition in what you're doing. For example, you'll have to call the `bsButton` function each time you want to create a button. This is expected and appropriate for you to do. After all, the purpose of the `bsButton` function is to create a button. 

However, you can over do the DRY principle. For example, you don't need to define a function for something that you're only going to call once. Further, it isn't necessary to define a new function that just changes a default value of an existing function. Here is a case where the user has over DRY-ed:

```{r dryCode4, echo=TRUE, eval=FALSE}
customButton <- function(inputId, label){
  return(
    bsButton(
      inputId = inputId,
      label = label,
      icon = icon("bolt"),
      size = "large",
      style = "success"
    )
  )
}
```

Rather than simply calling the `bsButton` function in their code and passing the appropriate arguments, this user has defined a brand new function that does the same thing but sets the values for `icon`, `size`, and `style` to new defaults. This type of programming should be avoided.

### Minimize Package Usage {#minPackages}

A second way to make your code more efficient is through the use of packages. When you load a package you want to be sure that 

1. the package you're loading is absolutely necessary, and
2. you maximize your usage of what packages you do load.

Make sure that you absolutely have to use a particular package before you do. Check to see if what you're trying to do can be done in a package you're already using or in base R. 

A previous student loaded the `scales` package to use the `percent` function to convert a decimal into a percentage. This was problematic for a couple reasons: the `percent` function has been depreciated (i.e., the package developers do not wish people to use it any more and plan to get rid of it) and it is unnecessary. What the student could have done is write the following bit of code: `paste0(0.1 * 100, "%")`. If needed in several places, they could have written their own function:

```{r percentFunction, echo=TRUE, eval=FALSE}
makePercent <- function(proportion){
  return(paste0(proportion * 100, "%"))
}
```

This is not to say that you can't make use of a new package. This guideline's purpose is to streamline the various packages that get used in BOAST and to use the most of the packages that we are using. However, there are times when we just need to use a new package. Please try to use packages that are housed on CRAN and are preferably under active development. Searching GitHub for the package name can help you decide whether the package is active.

To help you avoid name masking (i.e., [Section \@ref(explicit)](#explicit)), ensure that you are actually using a package, and to help future readers follow your code, explicitly call packages with their functions. For example, use `dplyr::filter([arguments])` instead of just `filter([arguments])`. If you are using a common package and have no risk of name masking, you can dispense with this. For example, you can use `ggplot([arguments])` rather than `ggplot2::ggplot([arugments])`.

You can also run a `funchir::stale_package_check` on your `app.R` file to see which packages you're loading but might not actually use in your code. These stale packages may then be deleted out from your library call.

```{r staleCheck, echo=TRUE, eval=FALSE}
# Check working directory
getwd()
# Does the output match the folder path to where you app lives?
# If not, then you need to set that. For example,
setwd("~/Documents/GitHub/shiny-apps/Sample_App")

# Run a stale package check on app.R, ui.R, and server.R
funchir::stale_package_check("app.R")
```

Be aware that while `stale_package_check` is useful, it doesn't always catch everything. For example, when we ran it on the sample app, we were told that there were no exported functions from `ggplot2` or `tippy`. However, we know that there are functions from both of those. If you have a giant list of libraries to check, there might be more misses.

Once you're sure that a package isn't being used, remove the `library` call for that package from your code.

## Be Kind to Future Coders {#beKind}

Keep in mind that we have a high coder turnover with a new group of students each summer. Thus, we need to ensure that we go out of our way now to help those students out. Strive to write the quality of code you wish you would have wanted to start with. If you follow the Readability and Efficiency Principles, you'll be well on your way to being kind to future coders. The best way to go above and beyond is through comments and titling code sections (making jump points).

### Leave Comments {#comments}

At bare minimum, use a comment to break your code into sections. This helps you and others conceptualize the code into more manageable chunks. Your comments can provide others with potential keywords to search for when looking at your code later on.

For particularly complex sections, use comments to summarize what you're trying to do. This can help you and others pick up the coding thread for what you are trying to do for troubleshooting, debugging, and future improvements.

Keep in mind that being kind is not only for other people, but also for yourself. When you come back to an app even after a couple days away, comments in addition to the readability and efficiency steps will help you see where you left off.

### Code Section Titles/Jump Points

Another way to be kind to future coders is to title sections of your code and create points which allow for them to jump to different sections of your code without having to scroll through each and every line. Remember, you also count as a future coder, so titling sections of code will help you navigate your code.

To title a section of code and make a jump point, start by making a comment in R. Then type a word/phrase that explains what the section is. Finally, type (at least) four dashes, `-`, (alternatively, you could use four equal signs, `=`, or four hashtags/pound signs, `#`) without spaces. This will create a title/jump point which people can use through the Code-Jump To... menu. You can vary the number of hashtags/pound signs at the start of comment to reflect where in the hierarchy of your app you are. Here's an example.

```{r jumpPoints1, echo=TRUE, eval=FALSE}
# Load Packages ----
library(shiny)

# Define gloabl constants, functions, data ----
## None for this example

# Define the UI ----
ui <- list(
  dashboardPage(
    ## Header ----
    dashboardHeader(
      # code omitted
    ),
    ## Sidebar ----
    dashboardSidebar(
      # code omitted
    ),
    ## Body ----
    dashboardBody(
      tabItems(
        ### Overview ----
        tabItem(
          tabName = "overview",
          # code omitted
        ),
        # code omitted
      )
    )
  )
)

# Define the server ----
server <- function(input, output, session){
  ## Info button ----
  # code omitted
}

# boastApp Call ----
boastUtils::boastApp(ui = ui, server = server)
```

<!--chapter:end:05-generalCoding.Rmd-->

# Shiny (BOAST) Specific Coding Practices {#specificCoding}

One of the most important aspects of Shiny apps is that they are interactive. Users not only can, but should be encouraged to manipulate various inputs to see what their explorations cause. However, making the most of Shiny's reactive environment does require that you take the proper steps.

## Overarching Organization {#orgCode}

As mentioned in the section on the [Template App](#appR), the format of your app.R file will need to be in a particular order:

1. Load packages through `library` calls
2. Define any global constants and functions; load data sets. (If you have written any functions into  other R files, use `source` calls here to load them.)
3. User Interface (UI) definition
4. Server definition
5. `boastApp` call

The User Interface (UI) will always be of the format
```{r userInterface1, echo=TRUE, eval=FALSE}
# Define the UI ----
ui <- list(
  # The code to create the interface
)
```

The Server will always be of the format
```{r server1, echo=TRUE, eval=FALSE}
# Define the Server ----
server <- function(input, output, session){
  # The code for creating your app's functionality
}
```

Finally, you'll always end your app with
```{r boastApp1, echo=TRUE, eval=FALSE}
# boastApp Call ----
boastUtils::boastApp(ui = ui, server = server)
```


## Calling Inputs and Outputs

One of the first things to keep in mind as you make your interactive app is that you need to plan for what will be the inputs (i.e., triggers) and what will be the outputs (i.e., the results). Shiny apps automatically create an `input` and an `output` object. As you create inputs and outputs in the UI, you'll often fill in an argument listed as `inputId` or `outputId`. These arguments will select the appropriate element from `input`/`output` based upon the name you pass. All inputs and outputs must have __unique__ names; be sure to make the [names informative](#naming).

In your server code, you will have to first invoke the `input` or `output` object then you'll need to call the name of the specific element you want to use. For example, if we want to call an input called "difficultyLevel", we would need to type `input$difficultyLevel` in our server code. If we want to send a plot called "lifeExpectancy" to the app, we would need to type `output$lifePlot <- renderPlot({lifeExpectancy})`. If you have worked with lists or data frames in R before, then using the dollar sign, `$`, to call named elements inside of a parent element should not be anything new.

## Reactive vs. Observe

In addition to `input` and `output`, there is another pairing you must become familiar with: `reactive` and `observe`. These are two classes of objects within the Shiny framework that impart special attributes to objects. In general, a `reactive` object anticipates changing over time and functioning as an input to other elements of your app. An `observe` object will call upon `reactive` elements, perform some task, and return an output. There are a couple of key differences between `reactive` and `observe`:

1. `reactive` elements can be used as inputs in other `reactive` elements as well as `observe` elements. `observe` elements cannot be used as inputs to other `reactive` (or `observe`) elements.
2. `observe` elements are *eager*--the moment they detect any one of their inputs changing, they update themselves as soon as possible. On the other hand, `reactive` elements are *lazy*--while they see when their inputs change, they don't update until they are called on by another element.

To help highlight this second difference, consider you picking up a cake from a bakery. If you were to act like an `observe` element, the moment the bakery called to say that the cake was ready, you'd drive to them and pick it up. If you were to act like a `reactive` element, you'd thank them for the call and make a note. When a friend asks you for the cake, that is when you head to the bakery to pick it up.

You will work with both `reactive` and `observe` elements (in particular with values and events) in your apps. While there are various ways in which you can do this, we detail the ways that we use (and want you to copy) them in BOAST.

If you want to learn more about the Shiny's Reactivity, please check out their [Understanding Reactivity page](https://shiny.rstudio.com/articles/understanding-reactivity.html).

## Working with Reactive Values

Reactive values are exactly what you might think: values which react to changes in your app. The only catch is that in order to use them, you must be in an a reactive environment. If you don't, you'll see the following error:

<div style = "color: red;">
>Error in .getReactiveEnvironment()$currentContext() : Operation not allowed without an active reactive context. (You tried to do something that can only be done from inside a reactive function.)

</div>

We will detail how to avoid these errors below.

There are three common ways to work with reactive elements.

### `input`

Anything to which you assign an `inputId` is automatically created as a `reactive` element. Whether you're making a button, a slider, a drop-down menu, etc., your app will store the value of that object which you can then use elsewhere in the code. As mentioned before to call (make use of) any input values you simply type `input$fieldName` where `fieldName` is whatever meaningful name you assigned.

The most common cause of the above error is putting `input$fieldName` in the wrong place. To avoid this error, you must ensure that you are inside an `eventReactive` or `observeEvent` call. 

### `reactiveVal`

The `reactiveVal` function allows you to create a single value (much like a variable in R) which will have `reactive` properties. One key usage of `reactiveVal` is that it allows you store values which you might want to update while someone uses the app, but not be an input. For example, suppose you want to keep track of a player's score while they are playing a game. This is a great place to use `reactiveVal`. We would code this in the following way:

```{r reactiveVal1, echo=TRUE, eval=FALSE}
server <- function(input, output, session){
  score <- reactiveVal(0)
  
  observeEvent(
    eventExpr = input$submit,
    handlerExpr = {
      if (correct){
        score(score() + 1)
      } else {
        score(score() - 1)
      }
      output$scoreDisplay <- renderUI({
        paste("Your current score is", score())
      })
    }
  )
}
```

In the above code, we've created `score` as a reactive element that starts with the initial value of 0. To call `score` and get its current value we need to use `score()`. To update `score`'s value we put the new value (or an expression) as an argument (e.g., `score() + 1`). Thus, the code `score(score() + 1)` says "take the current value of `score`, add 1, and then save as the new value of `score`".

Unlike `inputs`, app users don't directly change the values of a `reactiveVal`. Rather there's an intermediate step. Further, `reactiveVal` may be called outside fo `eventReactive` and `observeEvent`...provided that you are acting on global objects or constants. That is to say, you can't write `submitCounter <- reactiveVal(input$submit)` without getting the above error message. In order to use `input$fieldName` inside of `reactiveVal`, you must be inside of an `eventReactive` or `observeEvent` chunk. However, you can write `submitCounter <- reactiveVal(0)` and `submitCounter(1)` anywhere. 

### `reactiveValues`

One limitation of `reactiveVal` is that it is only a single value. This works fine if you just want that. However, let's say you want to keep track of multiple related values; for example, not only the user's score, but their number of attempts and how many times they used a hint. You could define three separate `reactiveVal` objects or you could use a single `reactiveValues` call. In essence, `reactiveValues` creates a list of `reactiveVals` for you.

```{r reactiveValues1, echo=TRUE, eval=FALSE}
server <- function(input, output, session){
  playerStats <- reactiveValues(
    score = 0,
    attempts = 0,
    hints = 0
  )
  
  observeEvent(
    eventExpr = input$submit,
    handlerExpr = {
      playerStats$attempts <- playerStats$attempts + 1
      if (correct) {
        playerStats$score <- playerStats$score + 1,
      } else {
        playerStats$score <- playerStats$score - 1
      }
    }
  )
  
  observeEvent(
    eventExpr = input$hint,
    handlerExpr = {
      playerStats$hints <- playerStats$hints + 1
    }
  )
}
```

A couple things to notice is that unlike `reactiveVal` you don't need to append `()` to the name to get the value and you don't need to place the new value as an argument. Rather you can use the assignment operator, `<-`, just as you would in regular R. By using `reactiveValues` to create a list, `playerStats`, we can create a clear conceptual link between `score`, `attempts`, and `hints` as well as have them travel together throughout the app. Outside of their nature of being a list of values, `reactiveValues` still acts like `reactiveVal`.

## Events

There are two major types of events that we use within the `server`: `eventReactive` and `observeEvent`. Just as you might expect from their names `eventReactive` is a `reactive` element and can be stored as an output while `observeEvent` is an `observe` element and can't be stored.

### `eventReactive`

One way to think about `eventReactive` is that it takes `reactiveVal`/`reactiveValues` and goes beyond in a couple of ways. First, you store more complicated objects than a value (e.g., a data frame). Second, you define a specific trigger to cause an update (i.e., the `eventExpr`). Here is an example `eventReactive` that will switch between various data sets, depending upon the user's choice (via `input$selectedData`):

```{r eventReactive1, echo=TRUE, eval=FALSE}
dataSet <- eventReactive(
  eventExpr = input$selectedData,
  valueExpr = {
    switch(
      EXPR = input$selectedData,
      "Iris" = iris,
      "Cars" = mtcars,
      "Penguins" = palmerpenguins::penguins
    )
  },
  ignoreNULL = TRUE,
  ignoreInit = FALSE
)

output$dataTable <- DT::renderDataTable(
  expr = dataSet()
)
```

In this example, any time the user changes the input field called "selectedData" (i.e., they change which data set they want to look at a.k.a. the "event"), the `dataSet` object will update. We can then use `dataSet()` to call the current data set and display that for the user in the output `dataTable`. Notice by using the `eventReactive` in this way, we don't have to write multiple instances of the `output$dataTable` to handle which data set is currently selected. Thus, `eventReactive` is a great way to keep our code DRY.

### `observeEvent`

As a contrast, `observeEvent` allows you to make use of `reactive` elements and cause things to happen BUT you can't save/store those things to be used elsewhere. We would use `observeEvent` if we want to update a plot, text, or other aspect of the UI for the user. As an example suppose that we want to create a box plot based upon the sample size and mean a user sets:

```{r observeEvent1, echo=TRUE, eval=FALSE}
observeEvent(
  eventExpr = c(input$sampleSize, input$mean),
  handlerExpr = {
    localData <- data.frame(
      x = rnorm(
        n = input$sampleSize,
        mean = input$mean,
        sd = 1
      )
    )
    output$dataPlot <- renderPlot(
      normBox <- ggplot(
        data = localData,
        mapping = aes(x = x)
      ) +
        geom_boxplot()
      normBox
    )
  },
  ignoreNULL = TRUE,
  ignoreInit = FALSE
)

```

Just as in `eventReactive`, we have the `eventExpr` argument. This is the trigger(s) that the code looks for changes to. In this case, we've tied the observer to two triggers--the sample size and the mean input fields. If the user changes either one of these, the app will immediately run the code that is in the `handlerExpr` (notice the use of curly braces, `{}`, to form a code block/chunk). Notice that we create `localData` and `normBox` as part of the `handlerExpr`. Both of these objects only exist inside this particular `observeEvent`. We cannot access them anywhere else given our current coding. Remember, `observeEvent` (and other `observe` elements) do not create stored and accessible objects like `reactive` elements.

### `ignoreNULL` and `ignoreInit`

Both `eventReactive` and `observeEvent` take the arguments `ignoreNULL` and `ignoreInit`. These are two *extremely* useful arguments to consider as you code your app. Both relate to what you are using as the `eventExpr`.

When you're working with input fields or reactive elements, you can run into cases where the input will have the value `NULL`. Suppose you've created a drop down list for a user to select things from and they have yet to make a selection. In this event, the value of  `input$userSelection` could be `NULL` (unless you've provided a default value). By setting `ignoreNULL = TRUE`, you instruct the `eventReactive`/`observeEvent` to not be triggered when `eventExpr` ends up with a value of `NULL`. To put this another way, setting `ignoreNULL = TRUE` will tell your app to wait for the user to do something before carrying out the event while `ignoreNULL = FALSE` will tell your app to immediately carry out the event.

When you launch a Shiny app two things happen before the user really even sees the interface: R reads all of the code and generates the user interface, and R activates (initializes) any `eventReactive` and `observeEvent` you've created. If you don't want the app to activate an event on initialization, you need to set `ignoreInit = TRUE`. If you want the app immediately carry out the event when the app loads, set `ignoreInit = FALSE`. Leaving `ignoreInit = FALSE` (the default) does carry some risks. If any code that is part of the `valueExpr` or the `handlrExpr` (not just `eventExpr`) has a value that is either `NULL` or needs the user to set to something valid, you can run the risk of your app encountering a fatal error and crashing when you try to run it. The following table provides a handy guide to getting the desired behavior out of `ignoreNULL` and `ignoreInit`:

| Desired Effect                                                                          | Set `ignoreNULL` to | Set `ignoreInit` to |
|---------------------------------------------------------------------|:-----------------------------:|:-----------------------------:|
| Run no matter what<br>(can cause fatal errors)                                          |       `FALSE`       |       `FALSE`       |
| Run every time except App Initialization                                                |       `FALSE`       |        `TRUE`       |
| Run whenever `eventExpr` isn't `NULL`<br>(the default)                                  |        `TRUE`       |       `FALSE`       |
| Run only when the user explicitly does something<br>(provided `eventExpr` isn't `NULL`) |        `TRUE`       |        `TRUE`       |

## Validation

In addition to `ignoreNULL` and `ignoreInit`, the `shiny` package provides an additional tool that you can use in any of `render*` functions (e.g., `renderPlot`, `renderText`, `DT::renderDataTable`, etc.): validation. Validation will check that any needed inputs are available AND are valid.

There are two components that you'll need to set up validation are the `validate` call and at least one `need` call. You only need one instance of `validate` inside of each `render*` function. You will use as many `need` calls as is necessary to fully set up all of the validation checks you want in place. This would will be the first thing that you write inside the `expr` argument of the `render*` function. For example, the following code ensure that the sample size set by the user is at least two before generating/displaying the scatter plot.

```{r validate1, echo=TRUE, eval=FALSE}
output$scatterPlot <- renderPlot(
  expr = {
    validate(
      errorClass = "leftParagraphError",
      need(
        expr = input$sampleSize >= 2,
        message = "Sample size must be greater than 2."
      )
    )
    ggplot(
      data = data.frame(
        # Rest of code omitted
      )
    )
  }
)
```

There is one named argument for `validate` and that is `errorClass`. This would be where you put extra text to fully specify which CSS class this error message should belong to. For more details on this, see the section on [CSS](#css). In most cases, you can omit this argument thereby just using the default.

Within the `need` function, you must specify two arguments: `expr` which is where you will define each validation check and `message` which is the text you want displayed for the user. For the `message` you should put something that will help the user fix the error.

## Connecting the User Interface and the Server

If you go back and look at some of the examples in the preceding sections you'll notice a reoccurring pattern when referencing outputs (e.g., `output$scatterPlot`, `output$dataPlot`, `output$dataTable`):

+ They all start with `output$` and immediately followed by a (semi-)descriptive name,
+ They all have the assignment operator, `<-`, and
+ They all are followed by a function whose name begins with `render*`

While accessing inputs from the UI is straightforward when you're in a reactive environment (e.g., `input$nameOfInput`), working the other direction (i.e., accessing the outputs) takes a bit more work. This is where the `render*` functions come into play. These functions will take whatever you place in them and prepare those objects so that they be placed into your UI.

In your UI you'll need to create a placeholder object in your code. For example, you'll need to have a line of code such as `plotOutput("histogram")`. This creates the space in your app for the `render*` functions to send the output. For each `render*` function there is a companion `*Output` function. Here is an example for displaying a histogram:

```{r renderExample1, echo=TRUE, eval=FALSE}
# UI Portion
ui <- list(
  dashboardPage(
    # code omitted
    dashboardBody(
      tabItems(
        tabItem(
          tabName = "example",
          p("Here's an example of histogram"),
          selectInput(
            inputId = "variable",
            label = "Select variable to plot",
            choices = c(
              "Miles/Gallon" = "mpg",
              "Quarter Mile Time" = "qsec",
              "Displacement" = "disp",
              "Weight" = "wt"
            )
          ),
          plotOutput("histogram")
        )
      )
    )
  )
)

# Server Portion
server <- function(input, output, session) {
  observeEvent(
    eventExpr = input$variable,
    handlerExpr = {
      niceLabel <- switch(
        EXPR = input$variable,
        "mpg" = "Miles/Gallon",
        "qsec" = "Quarter Mile Time (seconds)",
        "disp" = "Displacement (cubic inches)",
        "wt" = "Vehicle Weight (tons)"
      )
      output$histogram <- renderPlot(
        expr = {
          ggplot(
            data = mtcars,
            mapping = aes_string(x = input$variable)
          ) +
            geom_histogram(
              binwidth = function(x){ifelse(IQR(x) == 0, 0.1, 2 * IQR(x) / (length(x)^(1/3)))},
              color = "black",
              fill = "blue"
            ) +
            theme_bw() +
            xlab(niceLabel) +
            scale_y_continuous(
              expand = expansion(mult = 0, add = c(0,1))
            ) +
            theme(
              text = element_text(size = 18)
            )
        },
        alt = paste("Histogram of", niceLabel)
      )
    }
  )
}

```

There are a few things to notice in this code example:

+ The `selectInput` call makes use of "Named" Values which follow the pattern `"Text User Sees" = "textServerSees"`
    - This is useful so you can make human friendly display text but can still use the computer set names without having to rename/recode options elsewhere
+ We needed to include `plotOutput` in the UI so that R/Shiny knows where to send the histogram
+ We're using an `observeEvent` so that the plot automatically updates when the user changes `input$variable` (i.e., the `selectInput`)
+ There are TWO components `handlerExpr`:
    - The `niceLabel` object uses `switch` to prepare a human friendly label for our plot
    - We're using `renderPlot` to send the plot to the UI
+ Within the `renderPlot` we have another two __REQUIRED__ elements:
    - The `expr` is where you'll write the code to make the histogram
    - The `alt` provides alt text for your plot.
    - Not all `render*` functions will have the `alt` argument; `renderPlot` does and you are required to fill this argument in with meaningful text; see [Section \@ref(altText2)](#altText2) for more information.

(You might have also noticed some of the coding that is part of the `ggplot` calls such as the `theme_bw` and `scale_y_continuous`. Check out [Chapter \@ref(graphics)](#graphics) for more information.)

### Table of `render*` and `*Output` Companions

The following table contains the main pairings of functions that you'll need to use, from most to least common:

| Type of Object | In the UI | In the Server |
|:---------------|:----------:|:------------:|
| Plots | `plotOutput` <br /> *alt required | `renderPlot` |
| Tables <br /> Requires the `DT` package| `DT::dataTableOutput` | `DT::renderDataTable` |
| Grading Icons <br /> Requires the `boastUtils` package | `uiOutput` | `boastUtils::renderIcon`|
| User Interface Elements | `uiOutput` | `renderUI` |
| Text | `textOutput` | `renderText` |
| Raw Output | `verbatimTextOutput` | `renderPrint` |

There is some flexibility between the last three items that will depend upon what exactly you're trying to do. We'll handle those on a case-by-case basis. 

We do want to note here that sometimes you will see `htmlOutput` instead of `uiOutput`. We would like to use `uiOutput` as your primary choice.


<!--chapter:end:06-specificCoding.Rmd-->

# HTML and CSS {#htmlCSS}

Shiny apps are a blending of the R programming language and Hypertext Markup Language (HTML) which is the standard language of the web. When you run a Shiny app, `R` and the `shiny` packages actually convert all of the `R` code into an HTML document which is served up to the user. 

As you create the user interface, you will run into using HTML in two ways: functions for shiny (e.g., `bsButton`, `dashboardBody`, `selectInput`, `sendSweetAlert`, etc.) and HTML tags. In the case of the former, the functions you call will automatically write any necessary HTML when the app runs. For the later, you will have to take care to use tags appropriately.

## HTML Tags {#html}

HTML tags are the way in which you tell browsers what type of element you are creating. For example, if you want to tell the browser that you passing along text for the user to read, you would use the paragraph tag, `p`. If instead, you were passing along a file for an image, you would use the image tag, `img`. Shiny has 110 HTML tags built in. However, you will not need to use the vast majority of them. Instead, we will cover the ones that you will be using the most often.

One important word of caution here is that you need to pay close attention to the rules and guidelines in this chapter. If you don't use HTML tags appropriately, then 1) your app might not look/function the way that you intended, and 2) you'll make your app less accessible. Since our apps are to support students in their education, we need to do our best to ensure that all of our apps are as accessible as possible.

### Paragraphs {#paragraphs}

The most common HTML tag is that of paragraph. This is the tag that tells browsers "hey, here is some text content that I want you show the user". In your app, you'll encase the majority of any text in `p()` (more formally, `tags$p()`). 

For example,

```{r loadShiny, echo=FALSE, eval=TRUE}
library(shiny)
```

```{r paraTag1, echo=TRUE, eval=TRUE}
# Running this code produces a nice looking display of the text below.
p(
  "Statistics is the Liberal Art and Science of data to better
  understand our world in the face of omnipresent variation so that
  an individual can meaningfully participate in all levels of
  society."
)
```

No matter how short or long your content is, the paragraph tag should be your Go-To HTML tag. Treat the inputs of the paragraph tag exactly like you would write a document: separate paragraphs get their own instance of `p()`. Browsers will automatically put the appropriate space between them.

### Breaks

Another useful HTML tag is the one for breaks. No, we don't mean coffee/snack breaks. Rather we mean line breaks. These allow you end a line and move down to a new line (without an empty line between them) or even put a line of empty space between HTML elements. Thus, breaks are a great way to help with vertical spacing in your app.

To place a break all you need to type is `br()` (formal, `tags$br()`). One nice thing is that breaks can be typed into your code on their own or as part of another HTML element (e.g., a paragraph).

```{r breakTag1, echo=TRUE, eval=TRUE}
p(
  "Here's an example where we're using a break",
  br(),
  "inside of a paragraph tag."
)
```

### Lists

There are two aspects to lists: what kind of list you want to make (known as the list environment) and the items that make up your list. 

The two list environments are Ordered Lists and Unordered Lists.

+ The Ordered List environment is for when you require that a user works through the items in a particular order. You call this environment in your App by using `tags$ol( [your list] )`. These lists are sequentially numbered/lettered.
+ The Unordered List environment is for when you want to give the user a list where they can jump around between the items however they wish. You call this environment in your App by using `tags$ul( [your list] )`. These lists will appear with bullets.

You must first set up the list environment by using the appropriate HTML tag. Here it is good practice to use the formal call: `tags$ol()` and `tags$li()`. Failure to do this makes orphaned items which is an __Accessibility Issue__ and will cause the list to not be formated appropriately. 

Once you've created the list environment, you then tell browsers what the items are through the HTML item tag: `tags$li()`. (Again, use the formal call for safety.) The text of your item should be enclosed in quotation marks (double or single). 

You should __NOT__ use the paragraph tag or any header tags with your list items. This is poor coding: `h1(tags$li("First item"))`. The paragraph, header, and list item tags all communicate important and distinct information to browsers and assistive technologies like screen readers. If you mix these tags together, you'll create confusion for the browser and mess up accessiblity features.

You can use emphasis/italics or strong/boldface on portions of the content as appropriate; see the [Text Styling Tags](#stylingTags) section for details.

Here is an example of how you might create a list:
```{r listExample1, echo=TRUE, eval=TRUE}
tags$ul(
  tags$li("This is my first item."),
  tags$li("A second item word.")
)
```

If you wanted an ordered list, simply replace `tags$ul` with `tags$ol`:
```{r listExample2, echo=TRUE, eval=TRUE}
tags$ol(
  tags$li("This is my first item."),
  tags$li("A second item word.")
)
```

There is one exception to the environment that you need to be aware of: the Dashboard Header has a built-in list environment and thus you will jump straight to `tags$li()` when in that section only.

### Headers {#headers}

Heading tags provide a navigational structure to your app. Think of them as being the different levels of titles in a book. In fact, if you look at the Table of Contents to the left (provided you haven't hidden it), everything you see there is actually tied to a Header in this document.

No matter how much coders want, Heading Tags are __NOT__ for making text larger, boldface, or other text styling. Think about the headings as laying out a Table of Contents for your app, rather than containing content. Just like the Table of Contents for this Style Guide.

In fact, when you see different headers looking different (e.g., larger font size, boldface, etc.), this is *not* the due to the HTML heading tag; rather it is due to styling that is applied to the element through CSS. More on this later.

There is a specific ordering to the Header tags that is critical to ensure your App is accessible by screen readers.

1. `h1()` is for the Title of your App and should be ONCE at the top of the first page that appears when you load the app (i.e., the Overview).
2. `h2()` is for Page titles within the App. These would correspond with the links you place in the dashboard's left-side panel.
3. `h3()` is for titling Sections within a Page of the App. These might title the portion of the page that is for a game board, questions, answers, and graphs/plots.
4. `h4()` is for a Subsection within a section. You might use this to distinguish different sets of controls in a Controls section.
5. `h5()` and `h6()` should be used sparingly. These might be used for different levels of a game. When you call these in your App, you just call them as listed here; i.e., `h1()`, `h2()`, etc.

__Avoid skipping heading levels__ as this will get your App flagged for an Accessibility Violation. That is to say don't start at `h2` with no `h1` and don't go from `h1` to `h3` without an `h2`. Again, think of these as the layers of your table of contents or the outline of a paper; you wouldn't skip whole sections in either of those.

Here are few more things to NOT do with the heading tags:

+ DO NOT USE headings to style text (We cannot stress this enough.)
+ Do not wrap a header tag around a list element (e.g., `h3(tags$li("here is my list item"))`) nor the reverse (e.g., `tags$li(h3("here is my list item"))`)
+ Do not mix header tags together in the same line or with the paragraph tag (e.g., `h2("Introduction to", p("my game")))

For more information check out

+ [W3C's Tutorial](https://www.w3.org/WAI/tutorials/page-structure/headings/)
+ [Penn State's Headings and Subheadings Accessibility](https://accessibility.psu.edu/headings/)

### Links (#bodyLinks)

You might find yourself wanting to include a link in your text. For example, you might want to allow the user to go read up on your app's concept(s) before engaging further. To create a link you will need to use the HTML anchor tag, `tags$a()` and you'll need the following information:

+ The URL/web address that you want to reference (this is the Hypertext REFerence or HREF)
+ the text you want to be displayed. For accessibility, make the text descriptive of where you're sending the user (that is, don't use the phrase "click here").

The anchor tag must be used within a paragraph tag (`p()`) or a list item tag (`tags$li()`). Here's an example of using the anchor tag to create a link to the PSU's Stat Department website:

```{r anchorTag1, echo=TRUE, eval=TRUE}
p(
  "Learn more about us at the ",
  tags$a(
    href = "https://science.psu.edu/stat",
    "Penn State Statistics Department website.",
    class = "bodylinks"
  )
)
```

You'll notice that we added `class = "bodylinks"` to the anchor tag. Any time you're adding a link to the body of your app, you'll need to include this line. We'll explain more in the [CSS Section](#CSS).

### Divisions {#div}

A useful HTML tag is division, `div()` (formal, `tags$div()`); this tag allows you mark a chunk of your app as having special things applied to it. This is particularly useful for changing the alignment of text. The division needs to wrap around all of the elements that you want to include.

```{r div1, echo=TRUE, eval=TRUE}
div(
  style = "text-align: center;",
  p(
    "Here is some text. You can include other elements such as
    buttons, input fields, and output fields in addition to
    paragraphs and lists."
  )
)
```

### Horizontal Rule

On the rare occasion, you might find yourself wanting to draw a line in your app to help separate two chunks on the same page. For example, you might want to use a line to separate paragraphs of overarching instructions from paragraphs explaining a particular data set the user happens to pick. This is possible through the use of a horizontal rule. To create a horizontal rule, you simply place `hr()` on it's own line in your code (not inside of any other HTML tags). 

```{r hr1, echo=TRUE, eval=TRUE}
hr()
```

### Other Tags

There are a few other tags which you might need to use, depending upon your app. These include the image tag, `img()`, and the figure caption tag, `figcaption()`. We will discuss these tags in the chapter on [Static Images](#staticImages).

If you have questions about any other HTML tags, feel free to talk to Neil and/or Bob about them.

### Text Styling Tags {#stylingTags}

There are also some HTML tags whose goal is to work inside of the paragraph and list item tags to brings some extra information to text. These tags have a very visual impact on the text, which is why we refer to the Text Styling Tags. 

#### Italics/Emphasis

If you want to *italicize* a word or phrase, you'll need to use the emphasis tag, `tags$em()`. We want you to use the emphasis tag rather than the italics tag (`tags$i`) as emphasis is the __accessible__ option. The emphasis tag notifies screen readers to announce that the author has placed emphasis on the word or phrase. If you just use the italics tag, the user will not be notified of any differences between the word/phrase and surrounding text.

```{r emph1, echo=TRUE, eval=TRUE}
p(
  "You", tags$em("must"), "use the emphasis tag to ensure that your
  app is as accessible as possible."
)
```

#### Boldface/Strong

If you want to __boldface__ a word or phrase, you'll need to use the strong tag, `tags$strong()`. There is also a bold tag (`tags$b()`), but the same accessibility issues exist here. Thus, use `tags$strong()`.

```{r strong1, eval=TRUE, echo=TRUE}
tags$ul(
  tags$li(
    tags$strong("Level 1: "), "guess the sample size."
  ),
  tags$li(
    tags$strong("Level 2: "), "guess the sample size AND set variance."
  )
)
```

#### Code and Pre-formatted

If you want to display a block of code in your app (e.g., to show what code the user would need to type in order to recreate something on their own), you should use the code HTML tag, `tags$code()`. 

The code tag can replace the paragraph tag and tells browsers (and screen readers) that the enclosed text should be treated and styled as non-executed computer code.

To include a bit of code inside of a paragraph:
```{r code1, echo=TRUE, eval=TRUE}
p(
  "Use the ", tags$code("bsButton"), "function to create buttons in
  your Shiny app."
)
```

If you need to display several lines of code, you should also use the pre-formatted HTML tag (`tags$pre()`) to ensure that the browser does not change any spacing/indentation on you.
```{r code2, echo=TRUE, eval=TRUE}
tags$pre(
  tags$code(
'bsButton(
  inputId = "resample",
  label = "Generate new sample",
  size = "large",
  style = "default",
  icon = icon("retweet")
)'
  ) # Notice that the single quoted code doesn't match the usual coding alignment.
) # This is on purpose so that the we get the correct alignment in the rendered display below.
```

## HTML `id` {#htmlID}

No matter which HTML tag you use, you can always specify the identifier attribute (`id`) for each element. When you use a shiny function, e.g., `numericInput`, and you supply a value to the `inputId` argument, or when you define an output and set a value to the `outputId`, you are defining the HTML `id` attribute for that object. For the vast majority of cases, this will be your only method for interacting with HTML id's. 

In the rare case where you do find yourself needing to assign an `id` to an HTML element, you simply include `id = "uniqueName"` inside the tag. Keep in mind the id must not be shared by any other element/object, including inputs and outputs. 

```{r htmlID1, echo=TRUE, eval=FALSE}
p(
  id = "idExample1",
  "Here is some text whose paragraph now has the name 'idExample1'."
)
div(
  id = "idExample2",
  tags$ul(
    tags$li("Here's an example where the div"),
    tags$li("has the name 'idExample2' and contains"),
    tags$li("a list")
  )
)
```

## CSS {#css}

Cascading Style Sheets (CSS) are one of the most common ways in which people style HTML web pages. We have opted to make use of CSS technologies in BOAST through a centralized file. This ensures that 

1. we have a consistent feel across all of our apps,
2. we can ensure that our styling is as compliant as possible with [Web Accessibility Standards](https://www.w3.org/WAI/standards-guidelines/wcag/),
3. we can rapidly deploy changes to all apps, and
4. reduce the work load on the students (you).

At this point in time, only Neil and Bob make edits to the BOAST CSS file. However, anyone is welcome to recommend changes and additions as need arises. 

One of the perks of using the `boastApp` function, is that the loading of the BOAST CSS file is automatically done for you. The only things that you have to do is 1) write your app code, 2) use HTML tags appropriately, and 3) make sure to set the appropriate `skin` color in your app. Our CSS file will then do the rest (except for R plots).

### Problematic CSS in Old Apps {#cssProblems}

In many of the older apps, you will discover two highly problematic instances of CSS:

+ Calls to Non-BOAST CSS files
  - Look in the `www` folder for any files that end in `.CSS`
  - Look in the app for any code that looks similar to this:
    ```{r badCSS1, echo=TRUE, eval=FALSE}
    tags$link(rel = "stylesheet", type = "text/css", href = "/style.css")
    ```
+ In-line CSS
  - These would be lines that might look like the following:
    ```{r badCSS2, echo=TRUE, eval=FALSE}
    tags$style(HTML(".js-irs-0 .irs-single, .js-irs-0 .irs-bar-edge, .js-irs-0 .irs-bar 
                    {background: orange}")),
    # OR
    style="color: #fff; background-color: #337ab7; border-color: #2e6da4"
    ```

In both cases, CSS of questionable quality is at play and needs to be rectified. In many cases, these bits of CSS are interfering with the BOAST CSS. __We need to eliminate all of these instances.__

## Using CSS

When we first began implementing our central CSS file, there was some push back in that students wouldn't get any say in the styling of their apps. This is not necessarily true. What we have done is made a much more consistent and coherent set of options for the major elements. Each student still has the ability to put in place styling, as long as that styling adheres to our conventions and does not contradict the BOAST CSS file.

### Text Alignment

Students may use `style = "text-align: left/center/right;"` to impose styling choice of the alignment of elements. However, we do ask that students apply such styling to a division (`div()`) rather than to any other HTML tag. To see an example, see the [Division Tag example](#div).

Other than text alignment, we __discourage__ using the `style` argument with any CSS. (Note: some shiny functions like `bsButton` have a `style` argument which is different the `style` we're discussing here.)

### Classes {#classes}

The key way that students can style elements is through the use of classes which live in the BOAST CSS file. A class refers a group of elements which should all have similar styling. Any CSS file essentially consists of class definitions. If you want to apply a particular styling to an app element, the preferred method is through a CSS class. 

To apply a class to an element, all you need to do is supply the `class = "className"` argument. Classes may be applied to divisions, paragraphs and even inputs/outputs. For example,

```{r classes1, echo=TRUE, eval=FALSE}
# HTML Tag Example 1
p(
  class = "hangingindent",
  "Attali, D. and Edwards, T. (2018). shinyalert: Easily create
  pretty popup messages (modals) in 'Shiny'. (v1.0). [R package].
  Available from https://CRAN.R-project.org/package=shinyalert"
)

# HTML Tag Example 2
div(class = "updated", "Last Update: 12/2/2019 by NJH.")

# Function Call Example
actionButton(
  inputId = paste0("grid-", row, "-", column),
  label = "?",
  color = "primary",
  style = "bordered",
  class = "grid-fill"
)
```

#### Existing Classes {#existingCSS}

Here is a list of the current classes you may use

+ `largerFont` (for paragraphs): makes font 20% larger than the base font, __use sparingly__.
+ `updated` (for paragraphs): makes centered, smaller font size text for when the app was last updated.
+ `hangingindent` (for paragraphs): used in the Reference pages so that all subsequent lines of a reference are indented underneath the first line.
+ `answertext` (for paragraphs): makes text turn <span style = "color: #008755;">green</span>.
+ `bluetext` (for paragraphs): makes text turn <span style = "color: blue;">blue</span>.  
+ `redtext` (for paragraphs): makes text turn <span style = "color: red;">red</span>.
+ `bodylinks` (for anchors/links): makes the text change color depending upon the app's `skin` value, increases the font weight, and adds an underline: e.g., __<a href="https://www.psu.edu" style = "color: #1E407C; text-decoration: underline;">Penn State Website</a>__.
+ `leftParagraphError` (for use with `validate`'s `errorClass` argument): displays the validation error message as left aligned.

#### New Classes {#newCSS}

You might run into cases where you want an element styled in a new way or you might be the first person to use some new element (e.g., Fall 2020 was the first time someone used `matrixInput`) that needs BOAST styling. We can create new classes to handle these cases. However, we ask that you follow this process:

1. Get as many other bugs fixed in your app first.
2. Identify the element(s) that need the styling.
3. Write up at least one idea for what you're wanting.
3. Set up a meeting with Neil or Bob to discuss (we'll need an up-to-date version of your app prior to the meeting).
4. Meet with Neil/Bob to discuss and nail down what the new class will be called and do.

Be prepared for Neil/Bob to ask lots of questions about the intent of the styling during the meeting . We're doing this to make sure that the style decisions support the intent. By providing us with the most up-to-date version of your app, we can demo changes in real time for you. Once we get a class figured out, we'll add it to the BOAST CSS file and give you instructions on how to apply the class to the specific element(s).

We must issue a caution: if you're requesting a change to a common element such as a `sliderInput` which could ripple throughout all of the apps, we are going to ask a lot of questions about the purpose of such a change. You will need to have justifications prepared.


<!--chapter:end:07-htmlCSS.Rmd-->

# Additional Coding Practices {#additionalCoding}

The following coding practices arise much less frequently than our [Specific Coding Practices](#specificCoding) and [HTML/CSS](#htmlCSS). However, being aware of them will help you out in the long run.

## Plot Caching {#plotCachec}

Of these less frequent practices, Plot Caching is perhaps the most useful. Plot caching refers to the practice of your app to generate a plot once, save it, and then quickly serve the plot again and again to users. In essence, this is a method for improving the efficiency of an app. However, this is not something that always needs to be used.

The following cases represent some of the most common places where using plot caching is beneficial:

+ If your app includes a computationally intense plot (i.e., lots of data and/or layers) whose underlying data is fixed.
+ If your app has a dynamic graph that the user explores and needs to move back and forth between various states.

These cases represent a place where the performance of your app can suffer. To improve performance, you should consider using the `renderCachedPlot` function rather than `renderPlot`. This function will store a copy of each plot on the sever and provide that stored copy to new instances of the app. This cuts down on server demands and speeds up your app. For the third category, this allows the users to move more quickly to a previously examined state (i.e., low to no hang time).

There are two key arguments to `renderCachedPlot`: `expr` and `cacheKeyExpr`. The `expr` is the code chunk which will generate the plot or the name of plot object you've created elsewhere.

The `cacheKeyExpr` is the listing of all `reactive` elements that you want to tie the plot to. For example, if we set `cacheKeyExpr = { list(input$sampleSize, input$selectedData) }`, then the app will tie each saved version of the plot to the values of `sampleSize` and `selectedData`. The user sets these two inputs to a new pairing, your app would re-generate the plot. However, when the user sets them to a pairing that they've already looked at, your app immediately re-displays the saved plot. Plot caching also looks across all of the users, thus speeding up your app's plotting.

## Minimize External Files {#exFiles}

Try to minimize the number and size of external files you're attaching to your App. If you're working on an existing app, remove any external files that are no longer necessary.

Wherever possible try to place external files into the `www` directory/folder that is at the same level as your `app.R` or `ui.R`/`server.R` files.

If there are any external files (e.g., `*.csv`, `*.txt`, `*.dat`, `*.jpg`) that are not being used, delete them from the repository.

## Metadata {#metadatac}

As of boastUtils `v0.1.10`, your App will need the following metadata in a file named [DESCRIPTION](https://github.com/EducationShinyAppTeam/App_Template/blob/master/DESCRIPTION) (no file extension). This data is used to inform Learning Record Stores (LRS) about your App as well as provide information to instructors using the Instructor App (unreleased). See also our section on the [DESCRIPTION](#description) file in our chapter on the [App Template](#template)

**DESCRIPTION**
```{r metadatac, echo = TRUE, eval = FALSE}
Title: Sample App - A Lengthy Title
ShortName: Sample App
Date: 2021-05-13
Lifecycle: experimental
Authors@R: c(
    person(given = "Neil", family = "Hatfield", email = "neil.hatfield@psu.edu", role = c("aut", "cre")),
    person(given = "Robert", family = "Carey", email = "rpc5102@psu.edu", role = c("aut"))
  )
Chapter: Sample Chapter
Description: This app is focused on the common types of xyz.
LearningObjectives: c(
    "The student will learn to understand Concept A in way z.",
    "The student will learn to understand Concept B as description y."
  )
DisplayMode: Normal
URL: https://psu-eberly.shinyapps.io/Sample_App
BugReports: https://github.com/EducationShinyAppTeam/Sample_App/issues
License: CC-BY-NC-SA-4.0
Tags: simulation
Type: Shiny

```


## Other Languages (Python, JavaScript, etc.) {#otherLanguages}

Generally speaking, we want to keep the vast majority of our work within the R language (with the necessary HTML and CSS spots). Due to our turnover of coders, we won't always be able to ensure that we get someone who is proficient in additional languages such as Python, Rust, Netlogo, JavaScript, etc. 

See if what you're trying to do can first be done in R. If not, set up a time to speak with Bob and Neil to see about the appropriate way to go about using another language.

## Using rLocker {#rlockerc}

Because these apps are being developed for educational purposes, it is beneficial to collect data (logfiles) based on learning objectives and outcomes. The [rLocker](https://github.com/EducationShinyAppTeam/rLocker) package was created to aid in this process. It is important to know that the package itself does not perform feats of magic and will require some tuning to get right.

If you are following the directions we've laid out in this Style Guide, there is no additional action that you have to take. We provide the following information just for those individuals who would like to learn more about `rLocker`.

### Installing

```{r, eval = FALSE}
library(devtools)
devtools::install_github("EducationShinyAppTeam/rLocker")
```
[View Documentation](https://github.com/EducationShinyAppTeam/rLocker#Installation)

### Setup

Core configuration is included in the [boastUtils](https://github.com/EducationShinyAppTeam/boastUtils) package. Simply use the boastApp wrapper function instead of shinyApp and you're done! See [Creating an App](https://github.com/EducationShinyAppTeam/boastUtils#creating-an-app) for more information on how to use boastApp.

### Usage

The main purpose of this package is to help create meaningful- structured- xAPI data. xAPI (Experience API) can be thought of as the "Who did what, where did they do it, and when did they do it?" in your App. Statements are often structured as Actor, Verb, and Object that can also Result in something. For more on xAPI, check out [What is the Experience API?](https://xapi.com/overview/) or experiment with Statements in the [xAPI Lab](https://adlnet.github.io/xapi-lab/).

**For example:**

> **Bob** (Actor) **clicked** (Verb) **submit** (Object).

**In assessments:**

> **Neil** (Actor) **answered** (Verb) **Question 1** (Object) **correctly** with the answer **true** (Result).

This is a good way to think about it when beginning to write collection functions. Which brings us to our next part, writing collection functions.

Out of the box, `rocker` does not provide any collection functions for apps, only creation and storage mechanisms. Why is this? Every app is different! You know your app the best and what interactions are possible. Before storing data in a Learning Record Store (LRS) like [Learning Locker](https://www.ht2labs.com/learning-locker-community/overview/), it is important to transform it in a way that makes sense.

**boastUtils**

If using the `boastApp` wrapper for your project, your App will automatically generate and store a few of the more typical Statements. Please refrain from creating additional versions of the following statement descriptions:

| Statement   | Description                                   |
|:------------|:----------------------------------------------|
| launched    | User has started the app.                     |
| experienced | User has visited a tab (page) within the app. |
| exited *    | User has left the app.                        |

An App should only have one `launched` and `exited` event but can have multiple experiences per session. Therefore, you may use `experienced` in other places within your App.

\* Requires `boastUtils >= 0.1.5`.

**Sample generator function**

```{r, eval = FALSE}
.generateStatement <- function(
  session,
  verb = NA,
  object = NA,
  description = NA,
  interactionType = NA,
  response = NA,
  success = NA,
  completion = FALSE)
{
  statement <- rLocker::createStatement(list(
    verb = verb,
    object = list(
      id = paste0(getCurrentAddress(session), "#", object),
      name = paste0(APP_TITLE),
      description = paste0("Question ", activeQuestion, ": ", description),
      interactionType = interactionType
    ),
    result = list(
      success = success,
      response = response,
      completion = completion
    )
  ))
  return(rLocker::store(session, statement))   
}
```

**Sample event observer**

```{r, eval = FALSE}
observeEvent(session$input[[id]], {
  
  # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
  # BEGIN VALIDATION                                                          #
  #                                                                           #
  # For this example,                                                         #
  #   We will check if someone answered a question in our game correctly.     #
  #   Your code should be different here!                                     #
  #                                                                           #
    
  # The input element we're observing.                                        #
  object <- id
  
  # The user's action verb. Most likely going to be answered in this case.    #
  # Run rLocker::getVerbList() if you are unsure of the options.              #
  verb <- "answered"
  
  # The correct answer to the question.                                       #
  answer <- gameSet[id, "answer"]
  
  # The user's answer to the question.                                        #
  response <- input$ans
  
  # A description of the question or the full question itself (if short).     #
  description <- gameSet[id,]$question
  
  # The type of question it is.                                               #
  # Run rLocker::getInteractionTypes() if you are unsure of the options.      #
  interactionType <- ifelse(
    gameSet[id,]$format == "numeric", "numeric", "choice"
  )

  # Was the question answered successfully?                                   #
  success <- input$ans == answer
  
  # Did this event trigger the completion of your activity?                   #
  completion <- ifelse(.appState == "continue", FALSE, TRUE)
  
  #                                                                           #  
  # END VALIDATION                                                            # 
  # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
  
  .generateStatement(
    session,
    object = object,
    verb = verb,
    description = description,
    response = response,
    interactionType = interactionType,
    success = success,
    completion = completion
  )
}
```

Additional code can be found in the [examples](https://github.com/EducationShinyAppTeam/rLocker/tree/master/inst/examples) folder as well as the main [README](https://github.com/EducationShinyAppTeam/rLocker/blob/master/README.md) of the rLocker project; apps such as the [Hypothesis_Testing_Game](https://github.com/EducationShinyAppTeam/Hypothesis_Testing_Game) have already been outfitted with rLocker. The statement generator above will eventually make its way into `boastUtils` once enough feedback is collected. If you are ever confused about how it works, feel free to reach out to Bob ([rpc5102](mailto:rpc5102@psu.edu)).

**Did you know?**

You can run `help(package = "rLocker")` to view the help files for this package or press `F1` while typing a function name to see the documentation for that specific function.

<!--chapter:end:08-additionalCode.Rmd-->

# (PART) Style Guide-App Layout {-}

# App Layout {#layout -}

When considering the Visual Appearance of your App, there are two major areas of consideration: the [App Layout](#layout) and what we refer to as [Design Styling](#designStyle). Each of these will be handled in turn. Keep in mind that these two aspects are inter-related and have significant cross-over.

In this part of the Style Guide, we'll focus on the App Layout. The App Layout refers to all of our standards/guidelines for how you organize different elements of the user interface that are common to all of the BOAST apps. This ensures that all of the apps look like they belong together.

There are two main components to App Layout: the [User Interface Structure](#uiStructure) and [Common Elements](#commonElements). Each of these will be their own chapter.

# User Interface Structure {#uiStructure}

In this chapter, we will be focusing on the layout aspect of how your App looks.

A good number of the elements of the layout will have a direct consequence on your coding. For instance, in the section on [Organizing Your Code](#orgCode), you saw that the UI definition needed to come before the Server definition. This section defines additional organizational structure to your code as it pertains to the layout of your App.

As a reminder, one of the most important benefits of using the `boastApp` function from the `boastUtils` package is that is that certain aspects of Visual Appearance will be automatically handled for you. However, you still need to adhere to this Style Guide.

## Dashboard {#dashboard}

All apps will make use of a Dashboard structure. This divides the visual appearance of each App into three main areas. 

+ Across the top of the App will be the Header 
+ Along the left side of the App will be the navigation list (the Sidebar) where you will list the various Pages of your App
+ The last area is the Body; this is where all content will appear

Several of the older apps will have outdated UI calls including, but not limited to: `shinyUI` and `navbarPage`. These functions should no longer be used; apps that use them need to be updated to become compliant with this Style Guide. 

### Creating the Dashboard

Creating the overarching Dashboard layout in your App is actually quit easy:

```{r makeDashboard1, echo=TRUE, eval=FALSE}
# Required package
library(shinydashboard)

# [code omitted]
ui <- list(
  dashboardPage(
    skin = "blue",
    # [code omitted]
  )
)

```

The `dashboardPage` function will wrap around the rest of your UI element, thereby establishing the overarching structure. Three of this function's arguments (`header`, `sidebar`, and `body`) will be covered in following sections. We do not need to worry about the `title` argument as this will be controlled by the Dashboard Header. 

The one argument that you must explicitly set for the `dashboardPage` is the `skin` argument. This argument sets the overall color theme for your App. While this is something that is more an aspect of Design Style, your only opportunity to set this value is here with the Layout. 

### Color in the User Interface {#colorUI}

Within BOAST, we use color themes to help provide consistency for the elements of each app and to denote different chapters. Part of the standardization process of this Style Guide seeks to bring the many fractured color themes together into a cohesive, centrally managed set. This helps reduce the programming burden on the students, who should focus on the R side of the programming, not the CSS side.

All aspects of color in the User Interface should be controlled through the CSS file(s). This includes all of the following:

+ Dashboard coloring (Header, Sidepanel, Body)
+ Text coloring
+ Coloring of Controls (including buttons, sliders, and other input fields)

By using CSS, especially through `boastApp`, youll be able to ensure that there is consistent coloring throughout your App.

#### Implementing a Color Theme

To activate a color theme is a simple process, especially if you are following this Style Guide and using the `boastUtils` package. (In the rare case where you are using separate ui.R and server.R files, make sure that the boast.css call is in the ui.R file.

In your App's code, go to where you first call the function `dashboardPage`. Then, as the first argument you'll type `skin = "[theme]"` before moving on the next argument, `dashboardHeader`.

You will replace `[theme]` with one of the following: `blue`, `green`, `purple`, `yellow`, `red` or `black`. The choice will be determined by the color assigned to that chapter. This is all you have to do.

If you are unsure what color to put, use `blue` as the default.

#### The Themes

There are six color themes that we've currently made. The names of the themes are a general indication of coloring, with one exception. The `black` theme is not black but rather an aqua/teal set. The themes are typically three colors (four for `blue`) and based upon the Penn State Palettes. Non-Penn State colors will be denoted with asterisks. 

All of the themes have been checked against 8 different forms of color blindness.

##### Blue

The Blue Palette is our central palette and should be used by default. The Blue Palette looks like the following:
```{r bluePalette, fig.cap="The Blue Palette", fig.align='center', fig.width=6, fig.height=2, echo=FALSE}
ggplot2::ggplot() +
  ggplot2::geom_rect(
    mapping = ggplot2::aes(
      xmin = 0, xmax = 2,
      ymin = 0, ymax = 2),
    fill = "#1E407C"
  ) +
  ggplot2::annotate(geom = "text", x = 1, y = 1.25,
                    label = "Primary Color",
                    color = "white") +
  ggplot2::annotate(geom = "text", x = 1, y = 0.75,
                    label = "Beaver Blue",
                    color = "white") +
  ggplot2::geom_rect(
    mapping = ggplot2::aes(
      xmin = 2, xmax = 4,
      ymin = 0, ymax = 2),
    fill = "#009CDE"
  ) +
  ggplot2::annotate(geom = "text", x = 3, y = 1.25,
                    label = "Secondary Color",
                    color = "black") +
  ggplot2::annotate(geom = "text", x = 3, y = 0.75,
                    label = "PA Sky",
                    color = "black") +
  ggplot2::geom_rect(
    mapping = ggplot2::aes(
      xmin = -2, xmax = 0,
      ymin = 0, ymax = 2),
    fill = "#001E44"
  ) +
  ggplot2::annotate(geom = "text", x = -1, y = 1.25,
                    label = "Dark Accent",
                    color = "white") +
  ggplot2::annotate(geom = "text", x = -1, y = 0.75,
                    label = "Nittany Navy",
                    color = "white") +
  ggplot2::geom_rect(
    mapping = ggplot2::aes(
      xmin = 4, xmax = 6,
      ymin = 0, ymax = 2),
    fill = "#96BEE6"
  ) +
  ggplot2::annotate(geom = "text", x = 5, y = 1.25,
                    label = "Light Accent",
                    color = "black") +
  ggplot2::annotate(geom = "text", x = 5, y = 0.75,
                    label = "Pugh Blue",
                    color = "black") +
  ggplot2::theme_void()

```

Here is what the Blue Palette looks like in action:

```{r blueAction1, fig.align='center', fig.width=6, fig.height=4, echo=FALSE, fig.cap="Overview Page Using the Blue Palette"}
knitr::include_graphics("images/colorThemes/blueOverview.png")
```

```{r blueAction2, fig.align='center', fig.width=6, fig.height=4, echo=FALSE, fig.cap="Collapsible Boxes Using the Blue Palette"}
knitr::include_graphics("images/colorThemes/blueCollapse.png")
```

```{r blueAction3, fig.align='center', echo=FALSE, fig.cap="Sliders Using the Blue Palette"}

knitr::include_graphics("images/colorThemes/blueSliders.png", dpi=NA)
```

##### Green

The Green Palette looks like the following:
```{r greenPalette, fig.cap="The Green Palette", fig.align='center', fig.width=6, fig.height=2, echo=FALSE}
ggplot2::ggplot() +
  ggplot2::geom_rect(
    mapping = ggplot2::aes(
      xmin = 0, xmax = 2,
      ymin = 0, ymax = 2),
    fill = "#008755"
  ) +
  ggplot2::annotate(geom = "text", x = 1, y = 1.25,
                    label = "Primary Color",
                    color = "white") +
  ggplot2::annotate(geom = "text", x = 1, y = 0.75,
                    label = "Green Opportunity",
                    color = "white") +
  ggplot2::geom_rect(
    mapping = ggplot2::aes(
      xmin = 2, xmax = 4,
      ymin = 0, ymax = 2),
    fill = "#99CC00"
  ) +
  ggplot2::annotate(geom = "text", x = 3, y = 1.25,
                    label = "Secondary Color",
                    color = "black") +
  ggplot2::annotate(geom = "text", x = 3, y = 0.75,
                    label = "Future's Calling",
                    color = "black") +
  ggplot2::geom_rect(
    mapping = ggplot2::aes(
      xmin = -2, xmax = 0,
      ymin = 0, ymax = 2),
    fill = "#4A7729"
  ) +
  ggplot2::annotate(geom = "text", x = -1, y = 1.25,
                    label = "Dark Accent",
                    color = "white") +
  ggplot2::annotate(geom = "text", x = -1, y = 0.75,
                    label = "Penn's Forest",
                    color = "white") +
  ggplot2::theme_void()

```

Here is what the Green Palette looks like in action:

```{r greenAction1, fig.align='center', fig.width=6, fig.height=4, echo=FALSE, fig.cap="Overview Page Using the Green Palette"}
knitr::include_graphics("images/colorThemes/greenOverview.png")
```

```{r greenAction2, fig.align='center', fig.width=6, fig.height=4, echo=FALSE, fig.cap="Collapsible Boxes Using the Green Palette"}
knitr::include_graphics("images/colorThemes/greenCollapse.png")
```

```{r greenAction3, fig.align='center', echo=FALSE, fig.cap="Sliders Using the Green Palette"}

knitr::include_graphics("images/colorThemes/greenSliders.png", dpi= NA)
```

##### Purple

The Purple Palette looks like the following:
```{r purplePalette, fig.cap="The Purple Palette", fig.align='center', fig.width=6, fig.height=2, echo=FALSE}
ggplot2::ggplot() +
  ggplot2::geom_rect(
    mapping = ggplot2::aes(
      xmin = 0, xmax = 2,
      ymin = 0, ymax = 2),
    fill = "#491D70"
  ) +
  ggplot2::annotate(geom = "text", x = 1, y = 1.25,
                    label = "Primary Color",
                    color = "white") +
  ggplot2::annotate(geom = "text", x = 1, y = 0.75,
                    label = "Perpetual Wonder",
                    color = "white") +
  ggplot2::geom_rect(
    mapping = ggplot2::aes(
      xmin = 2, xmax = 4,
      ymin = 0, ymax = 2),
    fill = "#AC8DCE"
  ) +
  ggplot2::annotate(geom = "text", x = 3, y = 1.25,
                    label = "Secondary Color",
                    color = "black") +
  ggplot2::annotate(geom = "text", x = 3, y = 0.75,
                    label = "Stately Atherton",
                    color = "black") +
  ggplot2::geom_rect(
    mapping = ggplot2::aes(
      xmin = -2, xmax = 0,
      ymin = 0, ymax = 2),
    fill = "#000321"
  ) +
  ggplot2::annotate(geom = "text", x = -1, y = 1.25,
                    label = "Dark Accent",
                    color = "white") +
  ggplot2::annotate(geom = "text", x = -1, y = 0.75,
                    label = "Endless Potential",
                    color = "white") +
  ggplot2::theme_void()

```

Here is what the Purple Palette looks like in action:

```{r purpleAction1, fig.align='center', fig.width=6, fig.height=4, echo=FALSE, fig.cap="Overview Page Using the Purple Palette"}
knitr::include_graphics("images/colorThemes/purpleOverview.png")
```

```{r purpleAction2, fig.align='center', fig.width=6, fig.height=4, echo=FALSE, fig.cap="Collapsible Boxes Using the Purple Palette"}
knitr::include_graphics("images/colorThemes/purpleCollapse.png")
```

```{r purpleAction3, fig.align='center', echo=FALSE, fig.cap="Sliders Using the Purple Palette"}

knitr::include_graphics("images/colorThemes/purpleSliders.png", dpi= NA)
```

##### Black

The "Black" Palette is not pegged to the color black, but rather teal/aqua colors. However, to call the theme in the Shiny dashboard, the user must use the value `black` for the the `skin` argument. Here's what the "Black" Palette looks like:
```{r blackPalette, fig.cap="The 'Black' Palette", fig.align='center', fig.width=6, fig.height=2, echo=FALSE}
ggplot2::ggplot() +
  ggplot2::geom_rect(
    mapping = ggplot2::aes(
      xmin = 0, xmax = 2,
      ymin = 0, ymax = 2),
    fill = "#3EA39E"
  ) +
  ggplot2::annotate(geom = "text", x = 1, y = 1.25,
                    label = "Primary Color",
                    color = "white") +
  ggplot2::annotate(geom = "text", x = 1, y = 0.75,
                    label = "Creek",
                    color = "white") +
  ggplot2::geom_rect(
    mapping = ggplot2::aes(
      xmin = 2, xmax = 4,
      ymin = 0, ymax = 2),
    fill = "#69C9CB"
  ) +
  ggplot2::annotate(geom = "text", x = 3, y = 1.25,
                    label = "Secondary Color",
                    color = "black") +
  ggplot2::annotate(geom = "text", x = 3, y = 0.75,
                    label = "Teal*",
                    color = "black") +
  ggplot2::geom_rect(
    mapping = ggplot2::aes(
      xmin = -2, xmax = 0,
      ymin = 0, ymax = 2),
    fill = "#314D64"
  ) +
  ggplot2::annotate(geom = "text", x = -1, y = 1.25,
                    label = "Dark Accent",
                    color = "white") +
  ggplot2::annotate(geom = "text", x = -1, y = 0.75,
                    label = "Slate",
                    color = "white") +
  ggplot2::theme_void()

```

Here is what the "Black" Palette looks like in action:

```{r blackAction1, fig.align='center', fig.width=6, fig.height=4, echo=FALSE, fig.cap="Overview Page Using the 'Black' Palette"}
knitr::include_graphics("images/colorThemes/blackOverview.png")
```

```{r blackAction2, fig.align='center', fig.width=6, fig.height=4, echo=FALSE, fig.cap="Collapsible Boxes Using the 'Black' Palette"}
knitr::include_graphics("images/colorThemes/blackCollapse.png")
```

```{r blackAction3, fig.align='center', echo=FALSE, fig.cap="Sliders Using the 'Black' Palette"}

knitr::include_graphics("images/colorThemes/blackSliders.png", dpi= NA)
```

##### Yellow

The Yellow Palette looks like the following:
```{r yellowPalette, fig.cap="The Yellow Palette", fig.align='center', fig.width=6, fig.height=2, echo=FALSE}
ggplot2::ggplot() +
  ggplot2::geom_rect(
    mapping = ggplot2::aes(
      xmin = 0, xmax = 2,
      ymin = 0, ymax = 2),
    fill = "#E98300"
  ) +
  ggplot2::annotate(geom = "text", x = 1, y = 1.25,
                    label = "Primary Color",
                    color = "white") +
  ggplot2::annotate(geom = "text", x = 1, y = 0.75,
                    label = "Invent Orange",
                    color = "white") +
  ggplot2::geom_rect(
    mapping = ggplot2::aes(
      xmin = 2, xmax = 4,
      ymin = 0, ymax = 2),
    fill = "#FFD100"
  ) +
  ggplot2::annotate(geom = "text", x = 3, y = 1.25,
                    label = "Secondary Color",
                    color = "black") +
  ggplot2::annotate(geom = "text", x = 3, y = 0.75,
                    label = "Bright Keystone",
                    color = "black") +
  ggplot2::geom_rect(
    mapping = ggplot2::aes(
      xmin = -2, xmax = 0,
      ymin = 0, ymax = 2),
    fill = "#BF8226"
  ) +
  ggplot2::annotate(geom = "text", x = -1, y = 1.25,
                    label = "Dark Accent",
                    color = "white") +
  ggplot2::annotate(geom = "text", x = -1, y = 0.75,
                    label = "Lion's Roar",
                    color = "white") +
  ggplot2::theme_void()

```

Here is what the Yellow Palette looks like in action:

```{r yellowAction1, fig.align='center', fig.width=6, fig.height=4, echo=FALSE, fig.cap="Overview Page Using the Yellow Palette"}
knitr::include_graphics("images/colorThemes/yellowOverview.png")
```

```{r yellowAction2, fig.align='center', fig.width=6, fig.height=4, echo=FALSE, fig.cap="Collapsible Boxes Using the Yellow Palette"}
knitr::include_graphics("images/colorThemes/yellowCollapse.png")
```

```{r yellowAction3, fig.align='center', echo=FALSE, fig.cap="Sliders Using the Yellow Palette"}

knitr::include_graphics("images/colorThemes/yellowSliders.png", dpi= NA)
```

##### Red

The Red Palette looks like the following:
```{r redPalette, fig.cap="The Red Palette", fig.align='center', fig.width=6, fig.height=2, echo=FALSE}
ggplot2::ggplot() +
  ggplot2::geom_rect(
    mapping = ggplot2::aes(
      xmin = 0, xmax = 2,
      ymin = 0, ymax = 2),
    fill = "#BC204B"
  ) +
  ggplot2::annotate(geom = "text", x = 1, y = 1.25,
                    label = "Primary Color",
                    color = "white") +
  ggplot2::annotate(geom = "text", x = 1, y = 0.75,
                    label = "Original 1887",
                    color = "white") +
  ggplot2::geom_rect(
    mapping = ggplot2::aes(
      xmin = 2, xmax = 4,
      ymin = 0, ymax = 2),
    fill = "#F2665E"
  ) +
  ggplot2::annotate(geom = "text", x = 3, y = 1.25,
                    label = "Secondary Color",
                    color = "black") +
  ggplot2::annotate(geom = "text", x = 3, y = 0.75,
                    label = "Dawn of Discovery",
                    color = "black") +
  ggplot2::geom_rect(
    mapping = ggplot2::aes(
      xmin = -2, xmax = 0,
      ymin = 0, ymax = 2),
    fill = "#6A3028"
  ) +
  ggplot2::annotate(geom = "text", x = -1, y = 1.25,
                    label = "Dark Accent",
                    color = "white") +
  ggplot2::annotate(geom = "text", x = -1, y = 0.75,
                    label = "Land Grant",
                    color = "white") +
  ggplot2::theme_void()

```

Here is what the Red Palette looks like in action:

```{r redAction1, fig.align='center', fig.width=6, fig.height=4, echo=FALSE, fig.cap="Overview Page Using the Red Palette"}
knitr::include_graphics("images/colorThemes/redOverview.png")
```

```{r redAction2, fig.align='center', fig.width=6, fig.height=4, echo=FALSE, fig.cap="Collapsible Boxes Using the Red Palette"}
knitr::include_graphics("images/colorThemes/redCollapse.png")
```

```{r redAction3, fig.align='center', echo=FALSE, fig.cap="Sliders Using the Red Palette"}

knitr::include_graphics("images/colorThemes/redSliders.png", dpi= NA)
```

### Current Chapter Color Assignments {#chapterColor}

Here are the current (05/27/2020) color theme assignments for chapters:

+ Chapter 1: Data Gathering RED
+ Chapter 2: Data Description YELLOW
+ Chapter 3: Basic Probability BLUE
+ Chapter 4: Statistical Inference PURPLE
+ Chapter 5: Probability BLUE
+ Chapter 6: Regression "BLACK"
+ Chapter 7: ANOVA "BLACK"
+ Chapter 8: Time Series PURPLE
+ Chapter 9: Sampling RED
+ Chapter 10: Categorical Data YELLOW
+ Chapter 11: Data Science GREEN
+ Chapter 12: Stochastic Processes BLUE
+ Chapter 13: Biology GREEN

## Dashboard Header {#header}

Each Dashboard Header contains only a couple of elements. The most important of these will be a [shortened] Title of your App. This will automatically be followed by the sidebar collapse/expand button. At the far right, you will then include a link to the home page of BOAST using the Home icon with a link to a user survey back towards the center. 

Additional icons might be included to the left of the Home and Survey icons. However, these icons remain the same for all Tabs/pages of your App and are thus are not appropriate for Tab/page specific information.

There should not be any additional elements in the Dashboard Header. Any links for navigate in your App should appear in the Sidebar on the left edge.

The width of the Title component of the Header should be 250; `titleWidth = 250`.

### Creating the Dashboard Header

You will use the same structure regardless if you are using `app.R` or `ui.R`.
```{r makeHeader1, echo=TRUE, eval=FALSE}
# [omitted code]
dashboardHeader(
      title = "App Template", # You may use a shortened form of the title here
      titleWidth = 250,
      tags$li(class = "dropdown", actionLink("info", icon("info"))), # Optional
      # The next two are required
      tags$li(
        class = "dropdown",
        boastUtils::surveyLink(name = "App_Template") # Replace App_Template with the repo name for your app 
      ),
      tags$li(
        class = "dropdown",
        tags$a(href = 'https://shinyapps.science.psu.edu/',
               icon("home")
        )
      )
    )
)
# [omitted code]
```

A couple of things to notice: 

+ The `dashboardHeader` acts as a list environment, so it is safe to use `tags$li` here even though there isn't a `tags$ol` or `tags$ul`.
+ There are not a lot of elements to the Header. We only add additional elements here if it is something static (i.e., un-changing) that is necessary for all pages of your App.
+ You will need to set `class = "dropdown"` for each element after the `title` and `titleWidth`.
+ The `info` icon is optional; if you use this keep in mind two things:
    - You will need to define what the link does in the `server` definition.
    - This link's action remains the same for all tabs of your app. Thus, you should not use this to store or be the main conveyance of critical information/instructions for using a particular tab of your App.
+ The second to last element of the Header will always be the Survey link icon. This will take the user to a Qualtrics survey where they can provide us with feedback.
    - You'll need to use the `boastUtils::surveyLink` function here.
+ The last element of the Header (i.e., the rightmost) will always be the home icon which takes the user to the BOAST home page.

### What's Needed in the Server Definition

If you just have a bare bones Header (i.e., title, survey link, and home button), you do not need to add anything special to your server definition.

If you have anything else (e.g., an Info button), you will need to add additional code to your server definition. The code you add will depend upon the element. In general, for alert messages, we recommend that you use `shinyWidgets::sendSweetAlert`. Here's a generic example of what could be used for the Info button.

```{r infoServer, echo=TRUE, eval=FALSE}
# Required Packages
library(shinyWidgets)

# Move to your server definition
# Either look for server <- function(input, output, session) or open the server.R file.

# [omitted code]

observeEvent(input$info, { # Replace "info" with the appropriate id
  shinyWidgets::sendSweetAlert(
    session = session, # This should stay as is
    title = "App Information",
    text = paste("[Message you want to give to the student]",
                 "Use paste with multiple lines to",
                 "improve code reability."),
    type = "info" # This option will depend upon the nature of your message
  )
})

```

The `type` argument will take one of several options. use the one that best aligns with your purposes.

+ `info`: If you are just conveying some general information to your user, you'll use this value. This is the value that we will use in the vast majority of cases.
+ `error`: Use this if your message tells the user that have committed some action that causes your App to fail.
+ `question`: Use with an alert where you are asking the user to respond to a question.
+ `warning`: If you want to give your user the opportunity to stop from doing something destructive (e.g., deleting data values), this would be appropriate.
+ `success`: Use this if your message let's the user know that something worked correctly.

*Note: these buttons/links will throw an error when using the WAVE tool. This is expected at this time.*

## Dashboard Sidebar {#sidebar}

The Sidebar is the main navigational tool for your users. Thus, if you want your user to access a certain tab/page, you must be sure to include this in the Sidebar. The only exception is if you are creating a series of levels inside the same Exploration, Challenge, or Game. We refer to these as [Tabs Inside the Body or Tabs](#innerTabs) and are covered in their own section.

The Sidebar should have a width of 250, (`width = 250`).

For full descriptions of each type of Page, please refer to the [Dashboard Body Section](#body).

### Creating the Dashboard Sidebar

You'll need to use the following code as a template for creating the Sidebar. You will need to customize this to match your app's goals and design.

```{r makeSidebar1, echo=TRUE, eval=FALSE}
# [omitted code]
dashboardSidebar(
  width = 250,
  sidebarMenu(
    id = "pages", # Use "pages" to name the menu
    # Overivew is REQUIRED
    menuItem("Overview", tabName = "overview", icon = icon("dashboard")),
    # Prerequisites is optional
    menuItem("Prerequisites", tabName = "prerequisites", icon = icon("book")),
    # At least one of the next four is REQUIRED
    menuItem("Explore", tabName = "explore", icon = icon("wpexplorer")),
    menuItem("Challenge", tabName = "challenge", icon = icon("gears")),
    menuItem("Game", tabName = "game", icon = icon("gamepad")),
    menuItem("Wizard", tabName = "wizard", icon = icon("hat-wizard")),
    # References is REQUIRED
    menuItem("References", tabName = "References", icon = icon("leanpub"))
  ),
  # The sidebar must end with the following code, exactly
  tags$div(
    class = "sidebar-logo",
    boastUtils::sidebarFooter()
  )
)
# [omitted code]
```

Notice that after setting the `width` of the Sidebar, you will need to call the `sidebarMenu` function. This will create the appropriate structure for your Sidebar.

### Sidebar Order
To ensure consistency across all apps, the Sidebar needs to have the following order:

1. The Overview Tab should always come first.
2. If used, a Prerequisites Tab will come second.
3. An Activity Tab (Explore, Challenge, Game, Wizard, etc.) will come next.
4. If there are multiple Activity Tabs, then
    a. Order by Concept so that Tabs dealing with the same idea are together,
    b. Then order by Explore, Challenge, then Game
    c. If a Game Tab covers multiple Explore/Challenge Tabs, place after the last of the Explore/Challenge Tabs
    d. For a set of Activity Tabs of the same type (e.g., three Explore Tabs), the order will be up to you and the learning goals for your App
5. The References Tab will always come after the Activity Tabs and be the last element of the `sidebarMenu`.
6. The last element of the Sidebar will always be the PSU Logo. To ensure that this element is consistent across all apps, we will use a special function, `boastUtils::sidebarFooter`. You will need to copy the above code, including the `div` and use that exactly in your App. You'll place this code after (outside of) the `sidebarMenu` call but still inside the `dashboardSidebar` call. Please refer to the [Section \@ref(logo)](#logo).

*Note: this order will also dictate how you should organize your code in the [Dashboard Body](#body).*

### Sidebar Names

There are three pages whose names are fixed (i.e., you can not change): the Overview, Prerequisites, and References. The rest of the pages should be named according to the following conventions:

+ __Only One Page of Any Type__: when you only have one Activity page of a particular type (e.g., one Explore, one Challenge), you can use the type of activity as the name. That is, you can call the pages "Explore", "Challenge", etc.
+ __Multiple Pages of the Same Type__: when you have several pages that are all the same Activity type, you need to give each page an appropriate name. For example,
    - In the [NHST Caveats App](https://psu-eberly.shinyapps.io/Significance_Testing_Caveats/), there are three Explore pages: the Multiple Testing Caution, the Large Sample Caution, and the Small Sample Caution.
    - In the [One-way ANOVA App](https://psu-eberly.shinyapps.io/OneWay_ANOVA/) there are two Game pages: a Matching Game and a Fill in the Blank game.
+ __Clarity Matters__: The names of the pages need to be meaningful to others. Thus, you will need to ensure that
    - You don't use a name that is so long it doesn't get displayed properly.
    - You don't use a name that is confusing; the user should be able to anticipate where they are headed when they click on the link.
    - Related to the last, you don't set the user up to anticipate going to one activity but wind up at a different activity.

ff there is only one Activity Tab of each type, you may use the names Explore, Challenge, and Game.
+ If there are multiple Tabs of each type, you will need to rename each tab as appropriate. For example,
    - 

### Sidebar Icons

For each type of Page in BOAST apps, we use a specific icon in the sidebar menu. This helps establish a common theme across all of the apps so that users can have some instant familiarity as they interact with new apps.

In each `menuItem` call, you'll want to use the following code `icon = icon("iconName")` to ensure that the appropriate icon is used. The listing of what you'll use in place of `iconName` appears in the following table. Note: you'll want to make sure that you keep the quotation marks when you code.

| Page Type | `iconName` | Icon |
|:----------|:---------:|:----:|
| Overview | `"tachometer-alt"` | `r fontawesome::fa(name = "fas fa-tachometer-alt", height = "25px")` |
| Prerequisites | `"book"` | `r fontawesome::fa(name = "fas fa-book", height = "25px")` |
| Example | `"book-reader"` | `r fontawesome::fa(name = "fas fa-book-reader", height = "25px")` |
| Explore | `"wpexplorer"` | `r fontawesome::fa(name = "fab fa-wpexplorer", height = "25px")` |
| Challenge | `"cogs"` | `r fontawesome::fa(name = "fas fa-cogs", height = "25px")` |
| Game | `"gamepad"` | `r fontawesome::fa(name = "fas fa-gamepad", height = "25px")` |
| Wizard | `"hat-wizard"` | `r fontawesome::fa(name = "fas fa-hat-wizard", height = "25px")` |
| References | `"leanpub"` | `r fontawesome::fa(name = "fab fa-leanpub", height = "25px")` |

If you come across any of these types of pages that have a different icon or a missing icon, please create an issue in GitHub and/or fix.

If there is a type of page that does fit these, please talk to Neil to see about what we need to add.

### Submenus

Given the nature of our Apps, there is __NO__ reason for having submenus. If you come across an app that has submenus or you believe that a submenu is necessary, then that is a good sign that you are looking at a "bloated" app. These apps need to be marked for review to investigate re-designing the app and potentially splitting the app in to two or more apps.

### What's Needed in the Server Definition

If you have followed the above specifications, you do not need to add anything special to your server definition. The `dashboardSidebar` function will automatically take care of everything that is needed. 

The most important thing is that you keep track of what you set for each `tabName` argument. When you build the pages in the [Dashboard Body](#body) or want to create a button that sends the user to a particular page, these are the values that will be crucial.

## Dashboard Body {#body}

The Dashboard Body is where all content (text, images, plots, buttons, etc.) exists for the user to read, view, and interact with. Thus, this is the most important part of the layout of your App.

The order in which your code the Pages in the Dashboard body needs to mirror the order of the tabs in the Sidebar. This helps not only you keep track of where you're at, but is kind to future readers of your code.

The `dashboardBody` call will be the last element of the `dashboardPage` call inside of your User Interface (UI) list definition. Within the `dashboardBody` you will need to call the function `tabItems`. This will help your App make a connection between the menu items in your Sidebar and the pages that you make in the Body.

Inside the `tabItems` call, you will then need to create separate `tabItem` calls--one for each Page you listed in your Sidebar menu. Each `tabItem` has a critical argument __which you must explicitly set__: `tabName`. The `tabName` argument needs to match the `tabName` you used in the Sidebar. (Remember `R` is case sensitive, thus "Overview" and "overview" are viewed as two distinct objects.)

Once you have set the value for `tabName`, you can choose to include the code `withMathJax()`. This line of code is needed if you plan to include any mathematical formulas. You can omit this line if you are not going to. We will note that a safe default is to go ahead and include this line of code. We must stress that you have to include `withMathJax()` on each page of your app.

What comes after these two lines of code will be all of the code necessary to bring the page of your App to life. However, the most important thing to remember while you're coding in this section are __*commas*__. After you finish each bit of code and before you move on to the next item on the page, you must place a comma and then return to a new line.

The following code can serve as an example to help you get started:

```{r makeBody1, echo=TRUE, eval=FALSE}
# [code omitted]
dashboardBody(
  tabItems(
    tabItem(
      tabName = "overview",# needs to match the names you used in the Sidebar
      withMathJax(),# if you need to display mathematics, include this line
      h1("Sample Application for BOAST Apps"), 
      p("This is a sample Shiny application for BOAST."),
      h2("Instructions"),
      # [code for the page continues]
    ),
    tabItem(
      # repeat tabItem chunk for each subsequent page
    )
  )
)
# [code omitted]
```

The following subsections explain the purposes of each type of Page.

### The Overview Page

This page is __REQUIRED__ for all Apps. This is the main landing page of your App and should appear at the top of the Sidebar. The icon for this page must be "dashboard".

The Overview Tab must contain __ALL__ of the following elements:

1.  Long/Formal App Title (as Heading 1; this will be the __only__ instance of Heading 1 in your App)
2.  A description of the app (as paragraph text under the title)
3.  Instructions (as Heading 2)
4.  General instructions for using the App (using an Ordered List environment)
5.  A button that will take the user to the next page (see [Section \@ref(buttons)](#buttons) on buttons)
6.  Acknowledgments (as Heading 2)
7.  A listing of acknowledgments including, coders, content writers, etc. (as a paragraph)
8.  Last Element: `div(class = "updated", "Last Update: mm/dd/yyyy by FL.")` with mm/dd/yyyy replaced with the date of the update you pushed to the server and FL replaced with your initials.

The purpose of the Overview Page is the act like the front/home page of any newspaper, magazine, or website. Set the stage for what you want the user to learn through your App.

#### Creating the Overview Page

Here's an example of making an Overview Page:
```{r makeOverview1, echo=TRUE, eval=FALSE}
# In the UI Section
# Inside the Dashboard Body
#### Set up the Overview Page ----
tabItem(
  tabName = "overview",
  withMathJax(),
  h1("Sample Application for BOAST Apps"), # This should be the full name.
  p("This is a sample Shiny application for BOAST."),
  h2("Instructions"),
  p("This information will change depending on what you want to do."),
  tags$ol(
    tags$li("Review any prerequiste ideas using the Prerequistes tab."),
    tags$li("Explore the Exploration Tab."),
    tags$li("Challenge yourself."),
    tags$li("Play the game to test how far you've come.")
  ),
  ##### Go Button--location will depend on your goals ----
  div(
    style = "text-align: center",
    bsButton(
      inputId = "go1",
      label = "GO!",
      size = "large",
      icon = icon("bolt"),
      style = "default"
    )
  ),
  ##### Create two lines of space ----
  br(),
  br(),
  h2("Acknowledgements"),
  p(
    "This version of the app was developed and coded by Neil J. Hatfield
    and Robert P. Carey, III.",
    br(),
    "We would like to extend a special thanks to the Shiny Program Students.",
    br(),
    br(),
    br(),
    div(class = "updated", "Last Update: 5/14/2021 by NJH.")
  )
),

```

A few things to notice:

+ If you need a new line but not a new paragraph, you use the `br()` tag. 
+ The label for the button needs to be consistent with [Section \@ref(buttons)](#buttons).
+ There should __NOT__ be any spaces between letters of a button label. This is a violation of Accessibility as this destroys the label. While we might read "G (space) O" as the word "go", a screen reader reads out "gee" (pause) "oh" to the user.
+ There is no need to use boldface or colons with the section headings when you properly use Heading tags. Thus, "Instructions:" does not follow this Style Guide.
+ There should not be an "About" heading. The text between the Title of your App and the Instructions head serves as the description.

#### What's Needed in the Server Defintion

At bare minimum you will need to have one element in your server definition: the action for your button. If you have multiple buttons, you might need to have several more code chunks. 

Here is a generic example for the button on the Overview Page that moves the user to the appropriate next page:

```{r movementButton1, echo=TRUE, eval=FALSE}
# In your server section
# [code omitted]
observeEvent(
  eventExpr = input$go1, #append the button's inputId to input$ as the event expression
  handlerExpr = { # This is the action portion of your button and must be in { }
    updateTabItems(
      session = session, # This allows the user to move pages
      inputId = "pages", # the id of your Sidebar
      selected = "explore" # Name of page to go to
    ) 
})
```

In the rare case where you have other things happening on the Overview page, you'll need to include the appropriate calls in your server section to carry out those actions for you. 

### A Prerequisites Page

If your App needs to ensure that the user has the base understandings necessary to interact with your App, you'll need to create a Prerequisites Page. Otherwise, you can omit this page.

The icon for this Page must be "book". Use the word "Prerequisites" rather than "Pre-reqs", "Prereqs", or "Pre-requisites". 

#### Types of Prerequisites

There are two different types of prerequisites: technical/conceptual and contextual. Both of these go into the Prerequisites Page.

Technical/Conceptual Prerequisites cover ideas that the user needs in order to fully engage with your App's statistical goal. For instance, if your App is about ANCOVA, the ideas of ANOVA and building a linear model would be good candidates for technical/conceptual prerequisites.

Contextual Prerequisites cover ideas that which are beneficial for the user to understand a context you're using. For example, if you are referencing an astragalus, you should include a brief explanation and/or picture of an astragalus. 

Keep in mind that Contextual Prerequisites are different from the context which should be part of an Activity Page. If the information is necessary to interpret sliders/graphs and is *specific*, then you should include this information on the Activity Page. If the information helps the user say "Oh, that's what they mean by [blank]", that is good sign of something to put in the Prerequisites Page.

#### Text Links in Prerequisites (and Beyond)

*Note: what appears here is applicable any time you want to link to an webpage that is beyond BOAST.*

In as many instances as possible, we would like to provide the user with a link to Online Notes of a World Campus Statistics course. 

The link that you provide must take the user to the appropriate location. Do not send the user to the home page for a course; rather, take them to the relevant page. To do this, you'll need to explore the [Department of Statistics STAT ONLINE](https://online.stat.psu.edu/statprogram/) page and look through the courses. 

You will create these links in-line, not as a button. Thus, they must be part of a paragraph block (i.e., inside a `p()` with other text) or as part of list item (i.e., inside a `li()`). 

Your link must include descriptive text. Using "Click Here" is __not__ descriptive. Rather say where the link will take the user. If you look through the links that we've included in this Style Guide, we've been modeling this. This descriptive text not only helps all users anticipate where they are going but also improves the accessibility of the links. (Plus, have you ever tried to click a small link on your phone?)

Once you find the appropriate page, you'll need to copy the URL for your link. There are some instances where we might be able to find an existing anchor (look for two inter-locking rings to appear when you place your cursor over a title) or make a request for adding an anchor. These are especially useful if what you want to link to is only part of the page.

*Note: not all requests for anchors may be fulfilled and not all course notes have anchors.

The styling of the link will be managed by the BOAST CSS file. See the following examples as well as [HTML-Links](#bodyLinks) section.

Here's are two examples of how you would code a text link:
```{r textLinkEx1, echo=TRUE, eval=FALSE}
# [omitted code]
# Working in the UI section

# Example 1: in a paragraph
p("While not critical, you might wish to refresh your understanding on some of the basic shapes
  of graphs in statistics. A good resource for this would be the ", # Notice the ending space
  tags$a(
    herf = "https://online.stat.psu.edu/stat100/lesson/3/3.2#graphshapes", #the URL
    "STAT 100 Table of Graph Shapes", # the descriptive text for the link
    class = "bodylinks"
  ),
  ". Feel free to check that resource out." 
  # Notice the ending punctuation for the prior sentence is not part of the link.
)

# Example 2: in a list item
tags$ul(
  tags$li("Review the ", # Notice the ending space
    tags$a(
      herf = "https://online.stat.psu.edu/stat100/lesson/3/3.2#graphshapes", #the URL
      "STAT 100 Table of Graph Shapes", # the descriptive text for the link
      class = "bodylinks"
    )
    # List items don't necessarily need ending punctuation. 
    #Be consistent; either all items do or none.
  ) 
)
# [omitted code]
```

#### Creating a Prerequisites Page
Here's an example of the code needed to create the Prerequisites Page in the UI:

```{r makePrereq1, echo=TRUE, eval=FALSE}
# [code omitted]
tabItem(
  tabName = "prerequisites",
  withMathJax(), # this line only need if you display mathematics
  h2("Prerequisites"),
  p("In order to get the most out of this app, please review the following:"),
  tags$ul(
    tags$li("Pre-req 1"),
    tags$li("Pre-req 2"),
    tags$li("Pre-req 3"),
    tags$li("Pre-req 4")
    ),
    p("Notice the use of an unordered list; users can move through the list any way they wish."),
  p("A second style of doing prerequisites is with collapsible boxes:"),
  box(
    title = strong("Null Hypothesis Significance Tests (NHSTs)"),
    status = "primary",
    collapsible = TRUE,
    collapsed = TRUE,
    width = '100%',
    "In the Confirmatory Data Analysis tradition, null hypothesis significance tests serve as a
    critical tool to confirm that a particular theoretical model describes our data and to make a
    generalization from our sample to the broader population (i.e., make an inference). The null
    hypothesis often reflects the simpler of two models (e.g., 'no statistical difference',
    'there is an additive difference of 1', etc.) that we will use to build a sampling
    distribution for our chosen estimator. These methods let us test whether our sample data are
    consistent with this simple model (null hypothesis)."
  ),
  box(
    title = strong(tags$em("p"), "-values"),
    status = "primary",
    collapsible = TRUE,
    collapsed = FALSE,
    width = '100%',
    "The probability that our selected estimator takes on a value at least as extreme as what we
    observed given our null hypothesis. If we were to carry out our study infinitely many times
    and the null hypothesis accurately modeled what we're studying, then we would anticipate our
    estimator to produce a value at least as extreme as what we have seen 100*(p-value)% of the
    time. The larger the p-value, the more often we would expect our estimator to take on a value
    at least as extreme as what we've seen; the smaller, the less often."
  )
),
# [code omitted]
```

For more information on collapsible boxes, see [Section \@ref(collapsible)](#collapsible).

#### What's Needed in the Server Definition

Generally speaking, the purpose of the Prerequisites Page is to convey key background information for the user to double check they understand before moving into the heart of your App. Thus, this page contains static text and images. Thus, it is rare that you would need to include anything in the server definition for this page.

###  Activity Pages

The heart of your App is the one or more tabs where users interact with the App beyond simple navigation. These are the Activity Pages. Some apps will have a single activity, others several; deciding on how many is part of the design process.

Currently, we have five types of Activities in BOAST:

+ Example Pages, `r fontawesome::fa(name = "fas fa-book-reader", height = "25px")`
    - These pages center around a user looking through a static/fixed example.
    - Of all activity pages, these will have the most amount of text on the page and the least for them to do.
    - The goal here is to provide a more solid foundation for the user so that they can more deeply engage with an exploration or challenge activity page.
+ Exploration/Explore Pages, `r fontawesome::fa(name = "fab fa-wpexplorer", height = "25px")`
    - These pages center around the user exploring the target concept.
    - These pages will generally have more text on the page here than other types of Activities.
    - There are often guiding questions meant to help the user engage in productive explorations.
    - The goal is not to assess the user's understanding, but to support their construction of productive meanings for the concept.
+ Challenge Pages, `r fontawesome::fa(name = "fas fa-cogs", height = "25px")`
    - These pages center around a user challenging themselves by testing out their understanding of a concept.
    - While there might still be a fair amount of text on the page, there will be less than an Exploration page..
    - Questions here will be in-between a guiding question and an assessment question. 
    - The goal is to provide the user an opportunity to test and refine their understandings.
+ Game Pages, `r fontawesome::fa(name = "fas fa-gamepad", height = "25px")`
    - These pages center around the user reviewing a concept (or several) in a game like format.
    - These generally have the least amount of non-question text on the page (i.e., instructions).
    - The goal is to provide an opportunity for a student to review and practice one or more concepts.
+ Wizard Pages, `r fontawesome::fa(name = "fas fa-hat-wizard", height = "25px")`
    - This is the newest (and rarest) of the Activity Page types (currently only in the [Hasse Diagram App](https://psu-eberly.shinyapps.io/Hasse_Diagrams/))
    - This type of page centers on helping the student create something
    - The goal is to help students apply their understandings of a concept to create something, typically for a prompt external to the app.

We will talk more about the layout of the Activity pages in [Section \@ref(activityLayout)](#activityLayout).

#### UI and Server Definitions

We've opted to not include any specific examples of the UI or server code for the Activity pages here. Partly, we don't want to convey that there is only *one* way to code these pages by giving specific examples too early. Mostly though, we want to stress that the coding you do here depends almost entirely upon your goals for your App.

We will be giving examples of how to code particular elements that you might need to include in your app throughout this Style Guide; draw upon those examples to help you with particular elements. Further, we encourage readers to spend time looking at the live versions of the apps in the [Book of Apps for Statistics Teaching](https://sites.psu.edu/shinyapps/) and then looking at the matching code located at the [GitHub Repository for BOAST](https://github.com/EducationShinyAppTeam).

Keep in mind that of all pages in your App, the Activity pages will demand the most of you for coding. 

### References Page {#refPage}

The last page will be for your references. This Page is __REQUIRED__ and is where you will place a reference list for all of the following items that you used in your app:

+ All `R` packages you used
+ Sources of any Code you used directly or drew heavily upon from other people
+ Pictures and/or other images
+ Data sets
+ Refer to the [Chapter \@ref(documentation)](#documentation) [on Documentation](#documentation) of this Style Guide for more information.

The icon for this Tab must be "leanpub", `r fontawesome::fa(name = "fab fa-leanpub", height = "25px")`.

We will additionally place licensing information for your App at the bottom of the Reference page. We have created a function in `boastUtils` (version  0.1.6.1) that will automatically put the correct information on the page.

#### Creating a References Page

Creating a References Page mimics both the Overview and Prerequisites Pages' structure and is done in the UI section:

```{r makeRef, echo=TRUE, eval=FALSE}
# In the UI Section
# [code omitted]
tabItem(
  tabName = "references",
  withMathJax(), # Rarely, if ever, will you need MathJax in the references
  h2("References"),
  p( # Each reference is in its own paragraph
    class = "hangingindent", # you must set this class argument
    "Bailey, E. (2015), shinyBS: Twitter bootstrap components for shiny, R package. Available
    from https://CRAN.R-project.org/package=shinyBS"
    ),
  p(
    class = "hangingindent",
    "Carey, R. (2019), boastUtils: BOAST Utilities, R Package. Available from
    https://github.com/EducationShinyAppTeam/boastUtils"
    ),
  p(
    class = "hangingindent",
    "Chang, W. and Borges Ribeio, B. (2018), shinydashboard: Create dashboards with 'Shiny', R
    Package. Available from https://CRAN.R-project.org/package=shinydashboard"
    ),
  p(
    class = "hangingindent",
    "Chang, W., Cheng, J., Allaire, J., Xie, Y., and McPherson, J. (2019),  shiny: Web 
    application framework for R, R Package. Available from 
    https://CRAN.R-project.org/package=shiny"
  ),
  p(
    class = "hangingindent",
    "Hatfield, N. J. (2019), Caveats of NHST, Shiny Web App. Available from
    https://github.com/EducationShinyAppTeam/Significance_Testing_Caveats/tree/PedagogicalUpdate1"
  ),
  p(
    class = "hangingindent",
    "Wickham, H. (2016), ggplot2: Elegant graphics for data analysis, R Package, New York:
    Springer-Verlag. Available from https://ggplot2.tidyverse.org"
  ),
  br(), # Three blank spaces
  br(),
  br(),
  boastUtils::copyrightInfo()
)
# [code omitted]
```

#### What's Needed in the Server Definition

You do not need to place anything in the server definition for the References Page.

## Layout of Activity Pages {#activityLayout}

Now that we've discussed the more general layout of your App, we can turn our attention to the layout of your Activity pages. As previously mentioned, the layout you use here will need to support the goals of your App. While there are several possible styles, there is one firm constant that everyone must adhere to:

__Each page should contain all information/instructions necessary for the user to be able to interact with the activity without having to switch to other pages.__

In essence, if we were to give a person just the Activity page, they should be able to engage fully and completely with the activity without needing to refer to any other pages. This will ensure that you treating other pages as they are intended as well as ensuring your users can have success in using your App.

### Two Required Elements

No matter what layout you end up using, they all require the same two required first elements: a page title and some opening text.

#### Page Title

The Page Title will be enclosed in the Header 2 tag, `h2`, and should be a meaningful title related to what the user will be doing. For an Exploration/Explore page, you can't just say "Explore", you need to say *what* they will be exploring. Similarly, for the other types of pages. 

#### Opening Text

Immediately after the Page Title, you'll want to add some text, typically enclosed in the paragraph tag, `p`. This is where you'll want to 

+ give any specific background information,
+ set up any particular contexts, and/or
+ give instructions.

There is nothing worse for the user than getting to an Activity page and not knowing what they are supposed to do. The Instructions on the Overview are for using the *entire* App, not any one particular page. Thus, you need to have specific page instructions somewhere on the page.

Keep in mind that this is beneficial to all users, but especially those who are using assistive technology such as screen readers. If you put your instructions on a separate page or hidden somewhere else, you are now requiring that your user memorize those instructions. This is already cognitively demanding for sighted individuals, but for users with vision impairments, even more so.

### The Classical Layout

The Classical Layout for Activity pages is our most common/main layout style. This is the layout that you'll want to use unless there is a reason to use one of the others. Let's look at an example of this layout from the [Significance Testing Caveats app](https://psu-eberly.shinyapps.io/Significance_Testing_Caveats/):

```{r classicalLayout, fig.align='center', fig.width=6, fig.height=4, echo=FALSE, fig.cap="Classical Activity Page Layout"}
knitr::include_graphics("images/activityLayouts/classic.png")
```

You can see the two required elements (Page Title and Opening Text) are labeled in blue (see Figure \@ref(fig:classicalLayout)). After the opening text you'll notice an orange colored box labeled "Fluid Row with 2 Columns". Within that box, we have two visual columns: a portion of controls with a grey background and a portion of the plot. 

In this particular layout, we will always place controls such as sliders, number/text inputs, select options, buttons, etc. on the left and with a grey background. To the right, we will place any output results (e.g., plots, data tables, etc.) The split between the columns is typically 1/3 vs 2/3, although this can change to 1/2 vs 1/2. 

To create this layout, you'll need to reference the next chapter; specifically, [Fluid Rows and Columns](#rowsCols), and [Well Panels](#wellPanels).

### Visible Tabs {#visTabs}

One of the more common alternative layouts for Activity pages includes the usage of a set of tabs inside the page. For example, the [Assumptions of ANOVA app](https://psu-eberly.shinyapps.io/Assumptions_of_ANOVA/) uses this type of layout:

```{r visTabsLayout, fig.align='center', fig.width=6, fig.height=4, echo=FALSE, fig.cap="Visible Tabs Activity Page Layout"}
knitr::include_graphics("images/activityLayouts/visibleTabs.png")
```

The Visible Tab layout provides an opportunity for you to create a "parent" page that then houses several inter-related topics together. This type of layout is also useful if you want the user to flip through a variety of different plots while still referencing the same inputs.

Depending on your needs/goals, you can blend the Visible Tab layout with the Classical Layout as we'll see shortly. To build tab sets, you'll want to check out [Section \@ref(innerTabs)](#innerTabs).

*(I will note here that the Assumptions of ANOVA app could use several modifications.)*

### Hidden Tabs {#hiddenTabs}

An alternate version of the Visible Tabs layout is the Hidden Tabs layout. There is still a set of tabs within the page but the user can no longer click on the tabs and move around at will. This is particularly useful if you have built a game where users need to progress through levels in a particular order (e.g., [Descriptive Statistics App](https://psu-eberly.shinyapps.io/Descriptive_Statistics/)) or in a wizard environment (e.g., [Hasse Diagram App](https://psu-eberly.shinyapps.io/Hasse_Diagrams/)).

```{r hiddenTabsLayout, fig.align='center', fig.width=6, fig.height=4, echo=FALSE, fig.cap="Hidden Tabs Activity Page Layout"}
knitr::include_graphics("images/activityLayouts/hiddenTabs.png")
```

A key element that you must be sure to include when using the Hidden Tabs layout are some type of navigation controls for the user as shown in Figre \@ref(fig:hiddenTabsLayout).

### Sets of Controls

Another Activity Layout is a blending of several of the previous layouts and occurs when you have several sets of controls. In an upcoming release of the [Population Growth Model app](https://psu-eberly.shinyapps.io/Population_Growth), we've split the controls into three separate sets:

1. Initial values which apply to all models/situations (boxed in purple in Figure \@ref(fig:setsLayout)),
2. Model Type as a Visible Tab Set (top of orange box),
3. Model Specific Controls (Classic Layout with grey background; also in the orange box)

```{r setsLayout, fig.align='center', fig.width=6, fig.height=4, echo=FALSE, fig.cap="Sets of Controls Activity Page Layout"}
knitr::include_graphics("images/activityLayouts/setsOfControls.png")
```

This kind of layout is particularly useful for explorations where certain controls are getting used by several different aspects. This can also help to reduce the size of a Classical Layout's control area. Typically, we don't want the user to have to scroll far below the plot to change something. 

### Tic-Tac-Toe

Games are a common area where you might need to use a different layout than the Classical one. A good example here would be any of our Tic-Tac-Toe games such as the [Hypothesis Testing Game](https://psu-eberly.shinyapps.io/Hypothesis_Testing_Game/).

```{r tictactoeLayout, fig.align='center', fig.width=6, fig.height=4, echo=FALSE, fig.cap="Tic-Tac-Toe Activity Page Layout"}
knitr::include_graphics("images/activityLayouts/tictactoe.png")
```

## Tab Sets {#innerTabs}

There are two types of tabs within the Shiny ecosystem: there is `tabItems` which connect the Pages of the `dashboardBody` to the menu items of the `dashboardSidebar` and there is `tabsetPanel` which allows you to create a set of tabs inside a particular page.

The [Visible Tabs Layout](#visTabs) and the [Hidden Tabs Layout](#hiddenTabs) make use of this second type of tabs (i.e., `tabsetPanel`). 

Deciding on whether to use `tabsetPanel` is going to depend on several things:

1. Do you have two or more aspects that are related enough that they shouldn't be their own separate tabs/pages of your App?  
    a. If NO, then you shouldn't use `tabsetPanel`.  
    b. If YES, then continue.
2. Are any of your aspects something that would be better suited as a Challenge or Game tab?  
    a. If YES, move that aspect to a separate page. If you still have 2+ aspects, continue.  
    b. If NO, continue.  
3. Are the aspects independent enough that a person can skip a couple and still use the App successfully?  
    a. If NO, then you should re-consider your design.  
    b. If YES, then proceed with using `tabsetPanel` in you design.
4. For the elements going into the `tabsetPanel`, can a person use them in any order or do they need to be done in a fixed order?
    a. Any order, then use Visible Tabs with `type = "tabs"`.
    b. Fixed order, then use Hidden Tabs with `type = "hidden"`.

When you go to make a set of tabs, you need to do two things: 1) you have to create the set of tabs and 2) you then have to create each tab.

### Create the Tab Set

Once you've decided to create a set of tabs on a page of your app, you'll need to start coding the page as you would any other (see [Dashboard Body](#body) for more information) page. However, once you get to the point of wanting to create the tab set, you'll need to use the `tabsetPanel` function and set the value of two arguments and potentially a third.

Here is the code that creates the tab set panel in the Hasse Diagram app:
```{r hasseTabs, echo=TRUE, eval=FALSE}
# We're in the Dashboard Body of the UI
tabItem(
  tabName = "wizard",
  withMathJax(),
  h2("Hasse Diagram Wizard"),
  p("Follow the prompts to create a Hasse Diagram."),
  tabsetPanel(
    id = "diagramWiz",
    type = "hidden",
    ##### Step 1-Action and Measurement Units ----
    tabPanel(
      title = "First Step",
      value = "S1",
      h3("Response"),
      p("Please provide/describe the the primary/surogate response for your study."),
      # code omitted
    )
  )
)

```

The two arguments of `tabsetPanel` you need to provide are the `id` and `type`. The `id` allows for you to reference the tab set from anywhere in the app, which is useful for navigation. Make sure you use a meaningful and unique name here. The `type` argument will take one of two values: `tabs` or `hidden`. (At this time we do not allow for any other choices in BOAST.) The choice will come from Question 4 in the decision tree above.

The optional third argument you can set is the `selected` argument (e.g., `selected = "S1"`). This will let you set the initial tab displayed be something specific. However, our recommendation is that you should put the tabs into an order that makes the most natural progression. The first tab displayed should be the first tab you create within the set. Thus, you don't really need to set the `selected` argument here.

### Create the Tabs

In the above example code, you can see the first tab getting created with the `tabPanel` call. The `tabPanel` call acts much like the `tabItem` call that you use to create pages. The key difference are the `title` and `value` arguments.

The `title` argument is the phrase that you want to appear in the tab that users click on. Notice you still must set this value even when you are using Hidden Tabs. The `value` argument provides an opportunity to give an abbreviation of the tab's title for use with the `selected` argument. If you are including spaces or special characters in your tab's `title`, we recommend setting something simpler for the `value`. (The default value for `value` will be whatever you set as the value of `title`.) You'll use the `value` for any navigation controls.

### Moving Between Tabs

You can create navigation buttons to move between the various tabs in a tab set. This is especially important if you are using Hidden Tabs.

Within the `handlerExpr` of your button's `observeEvent` call, you'll need to include code similar to the following:

```{r tabMovement, echo=TRUE, eval=FALSE}
# In the server definition
## In the observeEvent for a particular button
### In the handlerExpr for that button
updateTabsetPanel(
  session = session,
  inputId = "diagramWiz", # From the tabsetPanel
  selected = "S2" # from the tabPanel
)

```

You'll need to use the `updateTabsetPanel` function to tell R that you're wanting to move the user to a new tab. The `inputId` argument will need to be set to the `id` value of the `tabsetPanel` you created and want to be working with. The `selected` argument will need to be the `value` from the `tabPanel` that you want to send the user to.

<!--chapter:end:09-layout.Rmd-->

# Common Elements {#commonElements}

This second part of the App Layout deals with the coding and set up of elements that are common across many of the apps in BOAST. We strive to use consistent coding for these elements as this will improve the user experience.

We anticipate that this chapter will be one of the chapters you most heavily reference as you work on developing your apps. Over time, you'll become more proficient at coding and will not need to rely on this chapter as much.

## Fluid Rows and Columns {#rowsCols}

HTML is a linear language, by this we mean that as browsers interpret each line of HTML, the rendered elements appear one after the other vertically, from top to bottom. Since Shiny takes your R code and translate all of it to HTML, our apps also get rendered in this linear format. Thus, the way you order your code should reflect a top-down construction of your page.

This linear flow works well in many cases...until you want to put two (or more) elements side-by-side. To make elements appear next to one another horizontally, we need to make use of two important functions: `fluidRow` and `column`.

The `fluidRow` function tells R/Shiny that you want to put multiple elements into the same row of the page. The "fluid" aspect refers to the fact that this function will automatically adjust the row by wrapping the content to fit the size of the screen. This is important to ensure that your app can respond to being on a mobile device like a phone or a tablet. (Regular elements such as the dashboard environment, paragraphs, etc. will automatically adjust.)

Using `fluidRow` is fairly straightforward. Simply call the function and list all of the elements that you want in the same row as separate (unnamed) arguments. The elements will get listed in the order you code them, left to right, in the displayed row. For example, `fluidRow(objectA, objectB, objectC)`.

Our practice is to be a bit more precise with how we want to divide up the space in a `fluidRow` call. This is where the `column` function comes into play. Each `fluidRow` is internally divided into twelve (12) columns. The `column` function allows us to say how many of those columns to give to a particular element (the `width` argument) as well as how many empty columns we want to put between the left edge or the previous filled column (the `offset` argument).

For example, say that we want to make a row that has two buttons: one at the left edge and one at the right edge. We can use `fluidRow` and `column` calls to achieve this:

```{r rowCol1, echo=TRUE, eval=FALSE}
# In the page layout portion of UI code
fluidRow(
  column(
    width = 2,
    offset = 0,
    bsButton(
      inputId = "button1",
      label = "Left button",
      # code omitted
    )
  ),
  column(
    width = 2,
    offset = 8,
    bsButton(
      inputId = "button2",
      label = "Right button",
      # code omitted
    )
  )
)

```

By using `offset = 8` in the second `column` call, we placed 8 empty columns between the first button and the second button. Further, each button gets to take up two columns of space (i.e., 2/12ths of the row) to appear (`width = 2`).

The most common coding problems to arise with `fluidRow` and `column` are:

+ Forgetting to place `column` inside of the `fluidRow`. This won't be a fatal crash of your app, but your app won't look right.
+ Not setting `width` to an integer between 1 and 12. You must provide a value for `width` in each `column` call.
+ Not checking that all `width` and `offset` totals add to 12 within a single `fluidRow`. Look through your `fluidRow` and add up all of the `width` and `offset` values. You want that sum to be 12 so that you know that everything will be appropriately arranged. If you go over 12, you might get an error and/or your app might scale/wrap elements in strange ways. Similarly for if you are under 12.

### Nesting `fluidRow`

While it is technically possible to nest `fluidRow` calls, we do not recommend doing so. This could look something like `fluidRow(column(width = 3, fluidRow(...)),...)`. This can create serious navigational problems for any users who rely on using their keyboard rather than a mouse to move through and interact with your App. If you find yourself wanting to nest `fluidRow`, stop yourself and reach out to Neil and Bob for alternative ideas.

## Well Panels {#wellPanels}

Well panels are visual styling that we use to help offset user controls (i.e., inputs) from both context and graphs (i.e., outputs). 

To place something inside of a well panel, all you need to do is wrap that object in the `wellPanel` function. However, the placement of the `wellPanel` call matters. 

If you wrap each individual element in `wellPanel` you'll get a separate well panel for each call. If you place `wellPanel` too high up in your code, you'll end up putting everything into the well panel.

```{r wellPanel1b, echo=TRUE, eval=FALSE}
# In the UI Section
# [code omitted]
# Inside a tabItem
fluidRow(
  column(
    width = 4, 
    offset = 0, 
    wellPanel( # Placing the wellPanel call here will wrap around all controls
      h3("Controls"),
      sliderInput(
        inputId = "mtcAlpha",
        label = "Set your threshold level, \\(\\alpha_{UT}\\):",
        min = 0.01,
        max = 0.25,
        value = 0.1,
        step = 0.01,
        animate = animationOptions(interval = 1000, loop = TRUE)
        ),
      br(), # creating vertical space between sliders
      sliderInput(
        inputId = "mtcTests",
        label = "Set the number of hypothesis tests conducted:",
        min = 0,
        max = 500,
        value = 5,
        step = 5
        )
      ) # this closes the wellPanel
    ), # this closes the first column
  column(
    width = 8,
    offset = 0,
    h3("Plot"),
    plotOutput("pplotMTC"),
    bsPopover(
      id = "pplotMTC",
      title = "Investigate!",
      content = "What happens to the number of statistically significant tests when you
      increase the number of tests?",
      placement = "top"
      )
    ) # closes second column
  ), #closes the fluid row
```

The above code highlights using the `wellPanel` to place all of the controls into a well panel as well as placing that well panel into the first column of a fluid row.

## Collapsible Boxes {#collapsible}

One technique that we can make use of to cut down on the amount of visible text on a page is through the use of collapsible boxes. Collapsible boxes are preferred than other methods in that 1) the content remains on the page and thereby accessible, and 2) the user retains control for when to show/hide this information. 

Two great places to consider using collapsible boxes include the Prerequisites Tab and __static__ Context Information across the top of an Activity Tab.

*Note: if the context information changes (e.g., can be switched due to user actions), then collapsible boxes should __NOT__ be used. The context in these cases should __always__ remain visible.*

### Creating Collapsible Boxes

To create a Collapsible Box, you'll need to work in th UI section of your code:

```{r makeCollapsibeb, echo=TRUE, eval=FALSE}
# [code omitted]
box(
  title = strong("Title for the Box"), # Use the strong tag
  # Give either the title of the review concept or "Context"
  status = "primary", # Leave as primary
  collapsible = TRUE, # This allows collapsing
  collapsed = FALSE, # Initial value
  # If the only collapsible item, use FALSE
  # If there are multiple, the first one is FALSE, others can be set to TRUE.
  width = '100%', # use this setting
  "The text that will 'disappear' goes here."
),
# [code omitted]
```

Given the static nature of the information in a collapsible box, you should not need to add anything to the server definition.

The styling of Collapsible Boxes is controlled by the central CSS file. If you use the above code as your template, the coloring will automatically match your App's assigned color theme.

## Buttons {#buttons}

One of the key ways in which users will interact with apps is by clicking on buttons. While there are two different functions for creating buttons, our primary choice is the `shinyBS::bsButton` function. The `shiny::actionButton` option will only be used in certain circumstances (e.g., Tic-Tac-Toe boards).

### Main Type of Button

Let's talk about the particulars of the `bsButton` function which is the call you should use to create buttons.

```{r buttonDemo1, echo=TRUE, eval=FALSE}
# You must have library(shinyBS) loaded in your app
bsButton(
  inputId = "meaningfulName",
  label = "Words to display on button",
  icon = icon("bolt"), # Optional
  style = "default",
  size = "large",
  disabled = FALSE
)
```

Of the listed arguments only three are absolutely required: `inputId` (you must give each button a unique, meaningful name so that you can reference the button in your server definition), `label` (you must put text on the button so your user knows what to click and what the button does), and `size` (we will use "large" in all but the rarest of cases).

### Labels

As we've just mentioned, every button must have something listed for the `label` argument. If you submit an app for review and your buttons have empty values for this argument (i.e., `label = ""`), your code will be rejected. Button labels must be text (you can't rely on a picture/icon alone) to ensure that all users can use the button. This is a critical design and accessibility issue.

Here are some guidelines for the text to use as your label:

+ All buttons must have some text. 
+ Do not include extra spaces (e.g., between letters or words) or extraneous symbols
+ Generally speaking, the text should be relatively brief and clear. 
  - Don't use "Go to the next page" when you could use "Next"
+ The text should make sense with the action of the button; for example,
  - "Reset" if the button resets something (a game, a plot, inputs)
  - "Submit" if the button triggers the app to grab and process input values
  - "Make Graph" if button causes a graph to be generated
  - "Show/Hide Graph" if a button makes a graph object appear/disappear
  - "Next" if a button moves the user along some path.
+ If the button references something like a particular tab (prerequisites, exploration, etc.), the text should reflect this.
  - "Explore!" for a button that takes a user to an Exploration tab.
  - "Prerequisites" for a button that takes a user to a Prerequisites tab.
  - "Challenge Yourself!" for a button takes a user to a Challenge tab.
  - "Play!" for a button that takes a user to Game tab.
+ If a button references an object like an activity packet or a download prompt the text should refer to that
  - "Activity Packet" for a button that would open up and/or download a packet for the user
  - "Download Data" for a button that would download a data file.
+ Clarity is essential. If there are multiple buttons on the page, make sure that you use clear text for what button does and/or references.

### Icons

One option you can include in your button is an icon. The icon will always appear to the left of your `label`. Keep in mind that not all buttons need an icon and you don't want to over-rely on the icon to communicate what the button does to your user. 

If you do decide to use an icon, you will want to make sure that the icon is consistent and supportive of your button's `label` and goal. That is to say, don't use an eraser icon if the button's job is automatically fill in a bunch of fields. Additionally, we have developed the following guidelines for using icons on buttons:

+ Game buttons (e.g., "Submit") generally do not have any icons.
+ Direction Buttons (e.g., "Next" or "Previous") may or may not have icons,
    - "Next" buttons can use `icon("forward")` call, `r fontawesome::fa(name = "fas fa-forward", height = "25px")`
    - "Back" buttons can use `icon("backward")` call, `r fontawesome::fa(name = "fas fa-backward", height = "25px")`
    - You should not used text based "icons" such as "<<" or ">>" as part of the `label`
+ A "Prerequisites" button will use the `icon("book")`, `r fontawesome::fa(name = "fas fa-book", height = "25px")`
+ Buttons that send users to other pages (except Prerequisites) will use `icon("bolt")` , `r fontawesome::fa(name = "fas fa-bolt", height = "25px")`
+ A reset button that clears just the current page should use `icon("eraser")`, `r fontawesome::fa(name = "fas fa-eraser", height = "25px")`
+ A button that will clear everything (e.g., Start Over) should use `icon("exclamation-triangle")`, `r fontawesome::fa(name = "fas fa-exclamation-triangle", height = "25px")`
+ A button to save or store user values should use `icon("save")`, `r fontawesome::fa(name = "fas fa-save", height = "25px")`
+ A download button will use `icon("cloud-download-alt")`, `r fontawesome::fa(name = "fas fa-cloud-download-alt", height = "25px")`

### Style (Color)

The `style` argument helps determine the coloring that gets used with your button. To ensure that you buttons' coloration works within the theme of your App, we've already set the colors through the central CSS file. Thus, the vast majority of the time, you may omit the `style` argument entirely OR if you want to write more complete code, use `style = "default"`.

Now, there are some times when we will encourage you to use a different key word with the `style` argument. You'll see these key words in several sections:

+ `warning`: Good for when you want the user to proceed with caution; for example a Reset page button.
+ `danger`: Good for when you want the user to think twice before clicking; for example, a Start over button.
+ `success`: Good for when you want to convey that the user can proceed safely; for example, a button that advances the user from an answer message to the next question in the game
+ `info`: Good for when you want to give some additional information; for example, a button that triggers game instructions popping up, a button that gives a hint, or a button that might filter a question pool.

### Disabled

The `disabled` argument allows you to create a button that users can not click on (`disabled = TRUE`) until certain conditions are met. Check out the next section on how to change aspects of your buttons while the app is running.

### Updating Buttons

One of the things that you can do while the app is running, is to change aspects of buttons based upon certain user actions. This would include changing the label, the icon, the style, and even whether the button is disabled. To update a button you'll need to use the `updateButton` function:

```{r updateButton, echo=TRUE, eval=FALSE}
# In your Server Code,
## Inside the handlerExpr of some observeEvent
updateButton(
  session = session,
  inputId = "buttonName",
  label = "newValue",
  icon = icon("newIcon"),
  style = "newStyle",
  disabled = TRUE # or FALSE
)
```

The first two arguments (`session` and `inputId`) are required. However, the rest are the ones that you might want to change. IMPORTANT: only list the arguments you actually want to change here. Thus, if you only wanted to disable a button, you would ONLY list `session`, `inputId`, and `disabled = TRUE`. If you were to list any of the others, you would also change them.

The `updateButton` function is especially important if you are using the `disabeled` argument of `bsButton`. You need to allow your users to click on buttons, when conditions are met. That is to say, if you have a button that is permanently disabled, then you should get rid of the button.

### Other Issues

There are a few other issues we wish to bring up in relation to buttons.

#### Shape

All of our buttons should have a rectangluar shape with sharp or barely rounded corners. (Tic-Tac-Toe buttons will appear square.) If you come across any buttons that are a different shape (circular, elliptical) flag the app as needing fixing. If you come across any buttons that are rectangular but have heavily rounded corners, also flag the app.

We do not allow for buttons to be any other shape.

#### Animation

Some of the older apps will "animate" the buttons. That is to say, they will look rectangular until you move your cursor/mouse over the button or click on them. At which point in time their shape and/or color will change. These apps should be flagged for fixing.

Any you put your cursor/mouse over a button, you should see only the following:
+ a slight thicking of the outer border,
+ a slight darkening of the button,
+ for a disabled button, the background should flash white

The three allowed are built-in behaviors of the `bsButton`. The other animations, especially the shape changing, are custom coding that we would like to remove (typically through inline CSS).

#### Linking Out

Occasionally, you might need a button to do something that would be external to the app. For example, download an activity file that is not part of the app or open a new browser tab to a particular place. In these cases, you won't code any actions in your server definition for button. Rather, you'll make use the `actionbutton` instead of the `bsButton`.

```{r actionButton1, echo=TRUE, eval=FALSE}
# In the UI Section
actionButton(
  inputId = "ap1",
  label = "Activity Packet",
  icon = icon("cloud-download"),
  onclick = "window.open('../../ActivityPackets/Caveats/')"
)
```

Notice that the `onclick` argument is what creates the action for button and references a relative path to a particular file. In this case a R Markdown file that lives the in directory called. (The actual file name isn't listed to ensure that the processed/rendered version of the RMD is what the users see.)

These cases are extremely rare. Consult with Neil and Bob before you use this type of method.

### Listening to Buttons

Creating buttons in your UI is one thing; setting up portions of your server defintion to listen to buttons is another thing. Whether you're using an `eventReactive` or `observeEvent`, you can use any button as the value of the `eventExpr`. 

All buttons are part of the automatically generated `input` object. To reference a button you'll need to use the character string that you set as the button's `inputId` and call the `input` object. For example, if we had a button with `inputId = "submitGuess"`, we would set `eventExpr = input$submitGuess` in an `observeEvent` call. This would allow us to use the user's click on the submit button to carry out actions such as grading/scoring and displaying feedback.

## Inputs

In addition to buttons, users will often interact with your App through the use of inputs. There are a variety of different kinds of inputs that you can make use of; some will be part of the base Shiny packages, others will come from some additional packages.

Generally speaking, use the simpliest style of input as you can as that will be easier for your users.

No matter what type of input you're using, there are two absolutely required arguments you must include with non-empty, non-null values: `inputId` and `label`. As we've explained, these two arguments are vital to create the input field, reference their values, and make the input accessible.

### Types of Inputs

Here is a listing of the most common inputs in BOAST.

Basic Inputs, part of the `shiny` package:

+ `checkboxInput`: create a single checkbox
+ `checkboxGroupInput`: create a set of related checkboxes (users may select one or more)
+ `radioButtons`: create a set of radio buttons where users may only select ONE of the options at a time
+ `sliderInput`: create a numeric slider bar (can have one or two knobs)
+ `numericInput`: create a field where users can enter a number
+ `textInput`: create a field where users enter text
+ `selectInput`: create a dropdown menu where users select one (or more) options

Inputs from the `shinyWidgets` package:

+ `switchInput`: create a toggle/switch between two options
+ `checkboxGroupButtons`: create a set of buttons that act like a set of checkboxes.
+ `sliderTextInput`: creates a slider with text labels (use sparingly and use this instead of `sliderInput` with extra CSS)

Input from the `shinyMatrix` package:

+ `matrixInput`: creates a matrix of either character or numeric inputs

Each of these inputs have different arguments that you will need to attend to as you code your App.

### Animation of Sliders

One feature of slider inputs is the option to include a Play/Pause button that allows the user to create an animation of your plot. Enabling this option can be quite useful if allowing the user to move through the whole set of slider values is desirable. 

To enable this, you'll need to make use of the `animate` argument:

```{r animateEx1b, echo=TRUE, eval=FALSE}
#[code omitted]
sliderInput(
  inputId = "mtcAlpha",
  label = "Set your threshold level, \\(\\alpha_{UT}\\):",
  min = 0.01,
  max = 0.25,
  value = 0.1,
  step = 0.01,
  animate = animationOptions(
    interval = 1000, loop = TRUE))
#[code omitted]
```

You can set `animate=TRUE`, `animate=FALSE` or invoke the `animationOptions` function as we've done in the example and recommend. This will force you to make some important decisions: namely, how long the slider should wait between each movement (`interval`, in milliseconds) and should the animation start over once the slider reaches the maximum (`loop`). 

The `interval` is going to the most challenging value to figure out. This timer *__ignores__* everything else; that is, it doesn't wait to see whether your plot has updated. Remember, the more complicated the process that generates your plot is, the longer your App will need to render the plot. Thus, you can quickly get into a case where the slider has advanced several times while your App is still trying to render the first update. While `renderCachePlot` can help speed things up, keep in mind that you still might need to play around with the `interval` value to ensure smooth functionality.  

Make sure when you're testing an animated slider to vary all of the parameters involved in the graph. This will help ensure that you test adequately.

The styling of the play/pause button will be controlled by the BOAST CSS file.

### Ordering Inputs

One of the most powerful aspects of Shiny apps is that the user interacts with them. Thus, we need to consider not only the ways in which user interact (e.g., buttons, sliders, text entry, etc.) but also the order in which you want the user to manipulate the inputs. Coming up with a single declaration for how to order inputs in all cases is not necessarily feasible. However, we can set up general guidelines for how to make decisions on ordering your inputs.

Please use the following guidelines for determining the order of inputs in the User Interface (UI):

1. In general, if you want your user to do things in certain order, make your inputs appear in that order.  For example, If you want them to pick a data set, then an unusualness threshold/significance level, what attribute to test, and then set a parameter value, then your inputs should appear in that order.
2. Make use of how we read the English language (i.e., Top-to-Bottom and Left-to-Right) to provide an implicit ordering for your user.
3. If a user needs to carry out steps in particular sequence for your App to run properly, then place your inputs inside of an Ordered List environment with explicit text on what they should do. For example,  
    1. Choose your data set: [dropdown]  
    2. Set your unusualness threshold/significance level  
       [slider]  
    3. Which attribute do you want to test: [dropdown]  
    4. What parameter value do you want to use: [numeric input]
4. If an input is going to reset other inputs you should either:  
    a. Warn the user before hand  
    b. Move the input to the top of the list  
    c. Program the input to not reset other inputs, or  
    d. Some combination of the above  
5. If the inputs are not dynamically linked to the output (e.g., plots automatically update with a change in the input's value), then you should include a button that says "Make Plot" at the end of the inputs.

## Correct/Incorrect Marks

In games, you can give the user a visual cue as to whether they are correct or incorrect through the use of three images:

```{r marksb, fig.align='center', echo=FALSE, fig.cap="Correct, Partially Correct, and Incorrect Marks", fig.show='hold'}
knitr::include_graphics("images/scoringMarks/right-07.png")
knitr::include_graphics("images/scoringMarks/part-right-08.png")
knitr::include_graphics("images/scoringMarks/wrong-09.png")

```

To display these marks you'll use the `renderIcon` funtion from the `boastUtils` package. There are two key arguments to the `renderIcon` fuction:

+ `icon`: you'll need to use either `"correct"`, `"partial"`, or `"incorrect"`
+ `width`: this will be the number of pixels you want the icon to be. The default is 36, which is good in most cases.

To turn off/hide these marks you can use `renderIcon()` without any arguments.

It is important that you only access these marks through `renderIcon` as we've pre-programmed consistent and appropriate alt text for these marks.

Their placement in your App will depend upon what makes the most sense.

## Alerts and Messages

A universal rule to keep in mind when building Apps is that users will do things that you did not intend for them to do. This can cause your App to crash. While we can't anticipate every possible way a user might inadvertently break your App, we can program ways to handle some of those actions. This is where sending alerts comes into play.

The most common type of message revolves around the inclusion of an Information button (the `r fontawesome::fa(name = "fas fa-info", height = "25px")` button in the Dashboard Header). This Information button provides a quick reminder of general instructions for the app. 

For both alerts and messages, we will turn to the `sendSweetAlert` function from the `shinyWidgets` package.

```{r sweetAlert1, echo=TRUE, eval=FALSE}
# In your server definition
observeEvent(
  eventExpr = input$exampleTrigger,
  handlerExpr = {
    sendSweetAlert(
      session = session,
      type = "info",
      title = "Title of Message",
      text = "message to user"
    )
  }
)

```

Notice that we need to place the `sendSweetAlert` function inside of an `observeEvent`. The four arguments we've listed are the four basic aspects you must program any time you want to send an alert or a message to your users.

The `session = session` argument does not need to change and ensures that the correct user gets the message. 

### Alert Types

The `type` argument acts much like the `style` argument for `bsButtons`. You may use any one of the following types:

+ `info`: This is the default type and is used for passing a message to the user.
+ `success`: This is when your message is related to the user reaching some achievement. For example, they have logged in, they have won a game, etc. This is NOT appropriate for getting individual questions correct.
+ `warning`: This is for when the user might have done something that could create a problem later on. Their action isn't necessarily a problem now, but could become one in the future.
+ `error`: This is for when the user has done something that will result in an error or App crash unless they take some other action. 

As you build error checking into your app, using `error` and `warning` for alert types will be important.

### Alert Title and Text

All alerts and messages should include a short `title` that be rendered with the actual message. (Any formatting of the title will automatically be taken care of.)

These titles should not be overly long or complicated. For `info` and `success` types of alerts using `"Information"` and `"Success!"` are often sufficient. 

While you could do something similar for both `warning` and `error` types, you might want to consider including a bit more information. For example, rather than using `title = "Error!"`, you might want to use `title = "Error: Invalid Sample Size"` instead. Notice that the title helps direct the user to what they need to fix. 

You can't put everything into the alert's `title` argument. This is where the `text` argument comes into play. Give more details __AND__ ways in which the user can fix the error with the `text` value.

Your message can be rather simple text (the previous example), or you can use HTML tags to make the message more structured:

```{r sweetAlert2, echo=TRUE, eval=FALSE}
observeEvent(
  eventExpr = input$info,
  handlerExpr = {
    sendSweetAlert(
      session = session,
      type = "info",
      title = "Information",
      text = tags$div(
        "Use the app in two ways:",
        tags$ol(
          tags$li(
            "Click on the ", tags$strong("Explore"), " page to explore how to
              read Hasse Diagrams and how to use them to figure out the proper
              denominator to use to test a give node/term."
          ),
          tags$li(
            "Click on the ", tags$strong("Diagram Wizard"), " page to use the
              app to build your own Hasse diagram. The wizard will walk you through
              the necessary steps and then produce a diagram you can save as well
              as the R code to re-create the diagram."
          )
        )
      ),
      html = TRUE # you must include this new argument
    )
  }
)

```

Notice that we had to include the `html = TRUE` argument to `sendSweetAlert`. You will need to do this any time you include HTML tags in the `text` argument.

```{r sweetAlert3, fig.align='center', fig.width=6, fig.height=4, echo=FALSE, fig.cap="Example of HTML Tagged Message"}
knitr::include_graphics("images/sweetAlert1.png")
```


## Popovers and Tooltips

Have you ever been on a website and as you move your mouse over different elements on the page, a bubble of text appears? What you've experienced is an example of a Popover or Tooltip. While these can be useful tools, more often than not, they are abused as they lend themselves to the "shiny" problem.

For information about popovers, rollovers, hover text, or tool tips, please see [Section \@ref(popovers)](#popovers).

## Progress Bars

Consider adding a loading bar to show the process for intense computations; this will help the user understand that your App is processing and not frozen/broken.

We will there are a couple of different methods out there for adding a progress bar. 

+ Use the `shinyWidgets` with their `progressBar`, `progressSweetAlert`, and `updateProgressBar` functions.
+ Use the `shinycssloaders` package's `withSpinner` function. 

At this point in time we do not have a strong preference on which method to use. Make sure you discuss your needs with others and get plenty of feedback.

<!--chapter:end:10-commonElements.Rmd-->

# (PART) Style Guide-Design Style {-}

# Design Style {#designStyle -}

Design Style is the second side of the Visual Appearance of every app. Here, we deal with visual aspects that go beyond the layout of your App. This includes issues of branding, color, how you make text look (font, size, emphasis), and graphics (plots, tables, and images).

We've broken Design Style into three parts:

11) ["Simple" Design Matters: Branding, Color, and Text](#simpleDesign)
12) [Static Images](#staticImages)
13) [`R` Graphics--Plots, Graphs, and Tables](#graphics)

You'll want to make sure that you look through each of these components, especially the section on R Graphics.

# Branding, Color, and Text {#simpleDesign}

The "Simple" Design matters include [PSU Branding](#logo), [Color](#colorChoices), and [Text Styling](#styleText). We refer to these as "simple" matters for the fact that for the most part, there is very little for you to have do decide. Rather, you just need to make sure that you are attending to guidelines we've laid out in this Style Guide. In other words, we've done all of the hard work for you in these cases.

## PSU Branding {#logo}

Given that we are all associated with Pennsylvania State University, we need to include the Penn State logo in each App. Rather than sticking the logo at the top of the Overview page, we are going to place the logo at the bottom of the sidebar. This has the benefit of having the logo appear throughout the entire App AND making the logo be as unobtrusive as possible.

If you have followed the directions for the [Sidebar Layout](#sidebar), then you don't have much to worry about as those instructions will ensure that you have properly branded your App.

## Colors {#colorChoices}

Your App needs to have a consistent color scheme throughout. The color scheme should be checked against colorblindness to meet [WCAG 2.1](https://www.w3.org/WAI/WCAG21/quickref/) Level AA. You can do so at the [Coloring for Colorblindness](https://davidmathlogic.com/colorblind/#%23000000-%23E69F00-%2356B4E9-%23009E73-%23F0E442-%230072B2-%23D55E00-%23CC79A7) website.  If you are following this Style Guide (as you should be) then the vast majority of this section will be automatically handled for you.

See [Section \@ref(colorUI)](#colorUI) and [Section \@ref(colorPlots)](#colorPlots) for additional information on the use of colors.

## Text Styling {#styleText}

Text styling refers the non-content aspects of the text on the page, such as the use of italics, boldface, alignment, as well as font size and color.

You should let the centralized CSS file do the heavy lifting for text styling. (Again, using `boastApp` will help you.) However, for this to work properly, you will need to tag content appropriately. (See the section on HTML, [Section \@ref(html)](#html).)

If you run into a situation where some element needs additional styling, __talk to Neil or Bob for help__. You might have come across an element that needs to get added the central CSS file or a bug.

### Headings

Use the Heading Tags for the short fragments that define the structure of your App. If you find yourself enclosing a complete sentence in Heading tag, you ARE NOT using headings correctly. Notice how the headings in this Style Guide arent complete sentences; your App should mimic this. Full sentences appear as regular paragraph text (i.e., enclosed in `p()`) and not be a Heading.

### Paragraph Text

If you enclose text that gives instructions or other information to your Apps users in `p()` or `li()` (the later should be wrapped in either `tags$ol()` or `tags$ul()`), your App will understand how to style that text correctly. The central CSS file contains controls that set the base font size much larger than Shiny does natively as well as making text sizing dynamic. (This is important for making our apps mobile device friendly.) Again, using `boastApp` makes this process easier.

If you want to make a certain word or phrase italic, you will need to wrap that text in `tags$em()`. Similarly, if you want do the same with boldface, youll use `tags$strong()`.

For example, this code:

```{r paraStyle1, echo=TRUE, eval=FALSE}
p(
  "When dealing with the ",
  tags$em("t"),
  "-distribution, we only have one parameter, the ",
  tags$strong("degrees of freedom"),
  "that we need to input."
)
```

Becomes:  

> When dealing with the *t*-distribution, we only have one parameter, the __degrees of freedom__ that we need to input.

Use italics (emphasis), and boldface (strong) sparingly.

### Mathematics

For the most part, any mathematics you need displayed should be done using [MathJax](https://www.mathjax.org/). Default to using inline typesetting with the `\\(` and `\\)` delimiters. If you need to use display style, you can use `\\[` and `\\]`. For the vast majority of mathematics, youll wrap both inline and display style mathematics inside of a paragraph environment (`p()`).

If youre writing mathematics directly in your app, remember youll need to escape the LaTeX commands by putting an extra backslash (\\) in front; e.g., `\frac{3}{4}` would need to be `\\frac{3}{4}`.

If youre reading in mathematical text from an external CSV file, you do not need the extra backslash in the CSV file.

If you need assistance in figuring out how to type up mathematics, please talk to Neil, Matt, or Dennis.

__Note:__ Double dollar sign delimiters are generally not recommended for displaying math as they can lead to unintended results. See: [Writing Mathematics for MathJax](https://docs.mathjax.org/en/latest/basic/mathematics.html).

### [Game] Question Text

The text used as a question in a game should NOT be wrapped in a Heading tag; wrap the text in a paragraph tag.

### Label Text (Buttons, Sliders, Other Inputs and Alerts)

By using the central CSS file, any text you included in/on buttons, dropdown menus, sliders, radio buttons, choices, and other inputs as well as alert messages and popups/rollovers, will automatically be styled correctly.

Do not use heading tags, the paragraph tag, italics/emphasis, or boldface/strong with input labels. Input labels should be written in sentence case (i.e., capitalize only the first word and any proper nouns).

You may use these tags with popups/rollovers.

### Feedback and Hint Text

Again, let the central CSS file handle the styling of this type of text.

### Text in `R` Plots

Unfortunately, any text in `R` plots does not get controlled by CSS. This means that youll have to play around with the settings. Using the `ggplot2` package to make your plots (or other packages based upon the `grid` framework like `lattice`) will allow you to use the `theme` aspect to control text in your App.

Here is an example for how to do this:

```{r plotText1, echo=TRUE, eval=FALSE}
# Create a ggplot2 object
g1 <- ggplot2::ggplot(data=df, aes(x=x, y=y, color=grp)) 
# Add your layers, for example
g1 + ggplot2::geom_point()
# Use theme to control text size
g1 + ggplot2::theme(
  plot.caption = element_text(size = 18),
  text = element_text(size = 18)
  )
```

You will need to play around with the settings to find the appropriate value; text size 18 appears to work out well in many cases.

__Note:__ The text in your plot might not behave well for dynamic re-sizing on different mobile devices.

### Text Case

When writing text, you should use the appropriate case (i.e., which words you capitalize):

+ Headings: Use Title Case
+ Paragraphs/lists: use sentence case
+ Input labels: use sentence case
+ Figure Captions: Use Title Case
+ Table Captions: Use Title Case
+ Graphs (see [Section \@ref(graphLab)](#graphLab))
    - Titles: Use Title Case
    - Axes: use sentence case
    - Legends: use sentence dase
+ Default: sentence case

<!--chapter:end:11-simpleDesign.Rmd-->

# Static Images {#staticImages}

Static image refers to any image you're using in your App which is not produced by `R`. These are usually PNG or JPG/JPEG files which you end up calling in the UI portion of your code.

Within your App's folder/directory, there needs to be a sub-folder/directory called `www`. This is the place where you'll need to place ALL static image files.

## Adding an Image

To include the image in your App, you'll need to make use of the image tag, `img`. When you run your App, Shiny automatically knows to check the `www` folder any time the `img` tag gets called. 

There are two main ways to add a static image: through a Figure Environment and In Line.

### Figure Environment

Here is example code for adding an image within a figure environment:

```{r imageEx1, echo=TRUE, eval=FALSE}
#[code omitted]
tags$figure(
  align = "center",
  tags$img(
    src = "astragalus.jpg",
    width = 600,
    alt = "Picture of an astragalus (bone die)"
  ),
  tags$figcaption("Image of Astragalus by Yaan, 2007")
)
#[code omitted]

```

In this first example, we've created a figure environment with the `tags$figure` call. The first argument we set in the figure environment sets whether the figure is left, center, or right aligned on the page. (Typically, we'll go with `align = "center"`.)

The second part of the figure is the actual call to load the static image; `tags$img`. (Much the heading and paragraph HTML tags, you can omit `tags$` in this case; we would rather be safe than sorry, hence why we've left this in our code.) You will need to provide at least two arguments (`src` and `alt`) to this call. The `src` is the exact name of the file from the `www` folder you want to load while `alt` refers to the [Alt Text](#altStatic) for the image.

The other argument (`width`) is one of two sizing arguments (along with `height`) that you can set to alter the size of your figure. Check out the [Sizing Section](#imageSize) section below.

The last portion of the figure environment is the `tags$figcaption`. The figure caption is an opportunity to give a bit of information about the figure AND provide any credit. In our example, we've mentioned what the image is a picture of (an astragalus) as well as citing who the image belongs to (Yaan). Figure captions do not replace Alt Text and Alt Text does not replace figure captions; these are both complementary and distinct elements of static images.

### In Line Images

Sometimes you'll want to put an image within the line of text rather than as a separate figure environment. This is possible and you would use code similar to the following:

```{r imageEx2, echo=TRUE, eval=FALSE}
#[code omitted]
p("Check your answer here -->",
  tags$img(
    src = "check.PNG",
    alt = "Success, you are correct",
    width = 25,
    height = 25
  ),
  "<-- Check your answer here"
),
#[code omitted]

```

Notice that here we did not use either `tags$figure` nor `tags$figcaption`, rather we just used `tags$img` within a paragraph environment. The biggest caution we need to give here is to make sure you find an optimal size for your image.

## Sizing Your Image (#imageSize)

All image files have a native size that is part of that file. For instance, the check mark image is 270 x 250 pixels. However, we overrode that that sizing with the `width` and `height` arguments. 

We recommend that you test out your app with the image's natural sizing (i.e., omit both `width` and `height` arguments) and see how that looks. From there, you can start a the testing process. Except in a few cases (like our checkmark example above), you will only want to set either `width` or `height` but not both. This will allow each user's browser to optimize the resolution of the image so that the image does not appear unduly stretched or compressed. Generally, go with changing the `width` argument.

How did we decide on what size to use? We tested out various sizes until we found one that appeared to work well with our goals (i.e., not too large, not too small, but just right). This Goldilocks Zone of image size will change between every app as well as for different images within the same app. Try different sizes out and ask for specific feedback on image sizes. While finding an optimal size and position for your image can take some time, seeing bad settings is pretty obvious. Feel free to reach out to Neil and Bob for assistance.

## Adding Alt Text to Static Images {#altStatic}

Any graphical element you include in your App __MUST__ have an alternative (assistive) text description ("alt text"). This provides a short description of what is in the image or plot for users who are visual impaired. (Tables, when properly formatted will handle this automatically.)

Here are several resources worth checking out:

+ [WebAIM Alternative Text Guide](https://webaim.org/techniques/alttext/#basics)
+ [Penn State's Image ALT Text Page](https://accessibility.psu.edu/images/alttext/)
+ [W3C's ALT Text Decision Tree](https://www.w3.org/WAI/tutorials/images/decision-tree/)

In the prior section on static images, you saw exactly how to set the alt text; here is a generic example:

```{r altText1, echo=TRUE, eval=FALSE}
#[code omitted]
img(
  src = "yourImage.PNG",
  alt = "Short description of what's in the pic",
  width = 25, height = 25
)
#[code omitted]

```

You MUST include *descriptive* alt text to each and every static image you include 

<!--chapter:end:12-staticImages.Rmd-->

# Graphics {#graphics}

One of the most powerful tools we have in Statistics and Data Science is graphics. This includes images/pictures, graphs/plots, and tables. You will want to make sure that all graphical elements are appropriately sized in the Body. If there is text in a static image/picture, you'll need to make sure that the text is legible on a variety of screen sizes.

We've already discussed both issues of color and text size in plots. For additional considerations, please refer to the following readings (ordered from most important to least):

  - [Tufte-Fundamental Principles of Analytical Design](https://www.dropbox.com/s/hb52991v09p8q91/Tufte%20-%202006%20-%20The%20Fundamental%20principles%20of%20analytical%20design.pdf?dl=0)
  - [Tufte-Chartjunk](https://www.dropbox.com/s/z8yrf4eqph6c2h4/Tufte%20-%202001%20-%20Chartjunk%20Vibrations%2C%20grids%2C%20and%20ducks.pdf?dl=0)  
  - [Kosslyn-Looking with the Eye and Mind](https://www.dropbox.com/s/62uegsribwdjtze/Kosslyn%20-%202006%20-%20Looking%20with%20the%20eye%20and%20mind.pdf?dl=0)

Remember, we always want to be modeling excellent graphing behaviors.

> All photographs can be fortified with words. --Dorothea Lange

> A picture is worth a thousand words...but which ones? --Unknown

Both of these quotations highlight that you need to include some text with your plots to help the user construct their understanding of what you're trying to show them.

## Titles and Labels {#graphLab}

Graph and Table titles should follow Title Case. Capitalize each word unless the word is "small" (e.g., of, an, etc.). The [Title Case website](https://titlecase.com/) can help you if you aren't sure. (This website also does other types of case such as camel case.)

Axis and Legend Labels will follow Sentence Case. That is to say only the first word of each axis label and the legend will be capitalized. The remaining words will be lower case with two exceptions (proper nouns and unit abbreviations).

When dealing with quantities on axes, you need to include the unit of measurement in the label. Typically, the unit will be placed in parentheses at the end of the label and use appropriate abbreviations. For example, "Height (in)", "Air pressure (mmHg)", "Resting heart rate (bpm)", etc. If the unit of measure is for a count, change the label to be along the followings lines: "Number of siblings", "Number of bikes owned", etc.

Labels should be informative without getting in the way of reading the graph.

## Font Sizes

A common area for adjustment in R graphics is that font size. Many times, we might need to adjust the size of the text used in a plot so that the axis labels and titles are easier to read. There are a couple of different approaches you can use to effect this: change the base font size or change the font size for particular elements.

The easiest approach is to change the base font size and then let `ggplot` do the necessary alterations. To go this route, you will need to do the following:

```{r fontSize1, echo=TRUE, eval=FALSE}
# Letting examplePlot be an already created ggplot object
examplePlot +
  theme(
    text = element_text(size = 18)
  )

```

The above code should set the default font size for the entire plot to be 18 pt will potentially scale from there.

If instead you wish to be a bit more precise with the font size for different elements, you would need to something like the following:

```{r fontSize2, echo=TRUE, eval=FALSE}
# Letting examplePlot be an already created ggplot object
examplePlot +
  theme(
    axis.title = element_text(size = 18),
    axis.text.x = element_text(size = 14),
    legend.title = element_text(size = 18),
    legend.text = element_text(size = 14),
    plot.title = element_text(size = 24)
  )

```

In this example code, we're instructing R to use size 18 font for the labels on both axes and the legend title. We're also using size 14 font for the text that occurs in the legend as well as along the horizontal axis. (The vertical axis's text will be the default size.) The plot's title will be 24 point.

There are many different aspects of size that you can adjust with the `theme` function; these are just a few. To see the full list, look at the Help documentation for theme (`?ggplot2::theme`). For each of the elements, you will need to use `element_text` with a `size` argument to dictate what font size should be used.

You will need to play around with the font sizes to find one that will work well in a wide variety of situations. Keep in mind, that the font __will not dynamically scale__ when you stretch/shrink the window or when you move between using a computer and mobile device.

## Axes and Scales

The default axes for `R`'s base graphics are, well, absolutely terrible. The algorithms for axes in `ggplot2` while better than base `R` are still in need of improvement. The default axes often do not fully cover the data as well as having gaps between the axes and the data. All this impedes the user's construction of meaning. Thus, you'll want to take control and stipulate the axes and scales to optimize what users get out of the plot. If you are providing multiple plots that the user is supposed to compare, make sure that they all use the same scaling and axes.

To force `ggplot2` to place (0, 0) in the lower-left corner and to control the scales, you will need to include the following:

```{r axesControl1, echo=TRUE, eval=FALSE}
# Create the ggplot2 object
g1 <- ggplot2::ggplot(...)
# Add your layer
g1 + ggplot2::geom_point()
# Control axes and scale
## Multiplicative Scaling of the Horizontal (x) Axis
## Additive Scaling of the Vertical (y) Axis
g1 + ggplot2::scale_x_continuous(
  expand = expansion(mult = c(1,2), add = 0)
) + 
  scale_y_continuous(
    expand = expansion(mult = 0, add = c(0,0.05))
  ) 
```

## Color and Plots in `R` {#colorPlots}

In `R` you can set color theme which you use in `ggplot2`. Additionally, the package `viridis` provides several additional color palettes which are improvements upon the default color scheme.

We have developed two custom palettes for you to use with BOAST apps. These palettes are the `boastPalette` and the `psuPalette` and are part of the `boastUtils` package. We have worked hard to ensure that these palettes are consistent with color blindness and web standards as well as consistent with our color themes.

```{r customPalettes, echo=TRUE, eval=FALSE}
# To call a color from the boastPalette use
boastUtils::boastPalette[1]
## Numbers go 1 through 9

# To call a color from the psuPalette use
boastUtils::psuPalette[1]
## Numbers go 1 through 8

# Both palettes get used in the order of what is listed.
```

```{r boastPalette, fig.cap="The Boast Palette", fig.align="center", fig.width=7, fig.height=4, echo=FALSE}
par(mar = c(0.25, 10, 0.75, 9.5))
boastUtils::showPalette(
  palette = boastUtils::boastPalette
)

```

```{r psuPalette, fig.cap="The PSU Palette", fig.align='center', fig.width=7, fig.height=4, echo=FALSE}
par(mar = c(0.25, 10, 0.75, 9.5))
boastUtils::showPalette(
  palette = boastUtils::psuPalette
)

```

To use these palettes (or ones from `viridis`) with a `ggplot2` object, you'll need to do the following

```{r examplePalette, echo=TRUE, eval=FALSE}
# Create ggplot2 object
g1 <- ggplot(
  data = df, 
  mapping = aes(x = x, y = y, color = grp, fill = grp)
) + 
  geom_point() +
# Tell R to use your chosen palette
  scale_color_manual( # If you use "color" in aes
    values = boastUtils::boastPalette
  ) + 
  scale_fill_manual( # If you use "fill" in aes
    values = boastUtils::boastPalette
  )  

# You can also call colors individually
ggplot(
  data = data,
  mapping = aes(x = x, y = y)
) +
  geom_point(
    fill = boastUtils::psuPalette[2]
  )

```

If you have more groups than eight/nine colors listed in the two palettes, consider reworking your examples as you could overwhelm the user with too many colors. (This also applies to using different shapes to plot points.)

### Color and Accessibility

Color can be a great tool to help highlight different cases. While we have striven to create palettes which are friendly for color blindness, we can go beyond color to help all users. One key way to do this is to partner color with the shape of a points and/or the style of line used. This can be done easily in `ggplot` by using both the `color`/`fill` aesthetic as well as the `shape` and/or `linetype` aesthetics. For example,

```{r colorShapeLine, echo=TRUE, eval=FALSE}
ggplot(
  data = exampleData,
  mapping = aes(
    x = height,
    y = weight,
    color = class, # color only stipulates the color for the border
    fill = class, # fill will color the entire point 
    shape = class,
    linetype = class
  )
) +
  geom_point(size = 1) +
  geom_smooth(
    formula = y ~ x,
    method = "lm",
    se = FALSE
  ) +
  theme_bw() +
  theme(
    text = element_text(size = 18)
  )

```

The above code will produce a scatter plot. The color and shape of the points will depend upon the value of `class` for each observation. Additionally, the plot will contain linear trend lines for each level of `class` that repeats the color used for `class` on the points and uses different styles of lines (solid, dashed, dotted, etc.) 

As with color, shape and line type can become taxing quickly. Thus, if you find yourself reaching multiple shapes/types (say 6 or more), we should reconsider the plot.

#### An Exception to Line Types

Currently, there is an exception to using different line types in conjunction with color. This is for the notion of creating multiple paths (e.g., see [Law of Large Numbers app](https://psu-eberly.shinyapps.io/Law_of_Large_Numbers/)). Here, it is not as important that a viewer can distinguish between the individual curves. What does matter is whether the individual sees how the various curves converge or diverge. Thus, for path type plots, we will not worry about using line type in conjunction with color.

### Common Color Usage

Throughout BOAST, we often have certain re-occurring elements in plots. These include elements such as estimates, null values, population parameters ("true value"), etc. To build consistency across the many apps, we use the following standardized colors for these elements:

+ Confidence Intervals
  - Containing the true value: `psuPalette[1]`
  - NOT containing the true value: `psuPalette[2]`
+ Population Parameter/true value: `psuPalette[3]`
+ Observed Estimate: `psuPalette[4]`
+ Null Value (Frequentist) or comparison value (Bayesian): "black"
+ Likelihood: "blue"

## Transparency

In different situations, we may want to set the transparency of a graph object to be something other than opaque. We can do this with the `alpha` aesthetic. The values for `alpha` go from 0 (transparent) to 1 (opaque). You may need to play with several different values to find the optimal setting for your plot.

## Histograms

When dealing with histograms, especially when using `ggplot`, we need to think about what to use as the width of the bins (or alternatively, the number of bins). The `ggplot2` approach has a default of 30 bins but is also complains when you use this setting:

<div style = "color: red;">
>`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.

</div>

To avoid this message from getting placed into your log as well as getting displayed to your users, you can either find an optimal number of bins (or bin width) OR you can invoke the Freedman-Diaconis Rule to set the value of `binwidth`:

```{r fdRule, echo=TRUE, eval=FALSE}
ggplot(
  data = data,
  mapping = aes(x = x)
) +
  geom_histogram(
    binwidth = function(x){ifelse(IQR(x) == 0, 0.1, 2 * IQR(x) / (length(x)^(1/3)))}
  )

```



## Tables {#tables}

Data tables can pose a challenge for individuals to comprehend. Just as a wall of text isn't conducive to helping a person understand what's going on, neither is a wall of data values. Thus, we need to be extreme judicious (picky) about incorporating data tables into any of our apps.

In web development there are two main types of tables: layout tables and data tables. 

+ Layout tables help control where different elements appear on the page. 
+ We need an additional distinction for data tables:
    - Summary Data Tables are tables that have summary information; typified by two-way tables (a.k.a. contingency tables or crosstabs) but might also include other things such as values of descriptive statistics stratified by groups. 
    - Data Sets are an entire data object, presented in tabular format

__Layout Tables should never be used in a BOAST App.__

Data Sets should be displayed __as sparingly as possible__. In order to include a Data Set display, you will need to have identified an explicit learning goal/objective that necessitates the user digging through a data frame. If you can't identify such a learning goal, you should NOT include a data frame.

If the goal is to allow the user to look through the data set OR to have access to the data, then __give a link__ to either the original source of the data (__preferred__) or for them to download the file.

Summary Data Tables can be used more often and can enrich the user's experience with your app. However, these must still be constructed in an appropriate manner.

Neither Data Sets nor Summary Data Tables should be inserted into your App as a picture. This is an big Accessibility violation. Use the directions below to create the appropriate type of data table.

### Displaying Data Tables

Your first step is to create a data frame object in your `R` code. 

+ If you are displaying a data set (rare), then you will either need to read in the data or call that data frame. For this example, we'll be using the `mtcars` data frame that is part of `R`. 
+ If you are making a Summary Data Table, you'll need to either use `R` to calculate the values and store in a data frame or create a data frame yourself.

In either case, be sure you identify what columns you're going to use. If your original data file has 50 columns, but your App only makes use of 5, drop the other 45. Only display the columns that you actually use.

Your next step is to decide on where to put this display (e.g., inside an Exploration Tab or as a separate page). This will help you identify where in your App's UI section you need to put the appropriate code. 

To ensure that your data table is accessible and responsive (i.e., mobile friendly), you will need to use the `DT` package.

```{r installDT, echo=TRUE, eval=FALSE}
install.packages("DT")
# Be sure to include this in your library call
library(DT)
```

In your UI section, you'll need to use the following code, placed in the appropriate area:
```{r dtUICode1, echo=TRUE, eval=FALSE}
# [code omitted]
DT::DTOutput(outputId = "mtCars")
# [code omitted]
```

Then, in your Server section, you'll need to use the following code:
```{r dtServerCode1, echo=TRUE, eval=FALSE}
# [code omitted]
# Prepare your data set with only the columns needed
carData <- mtcars[,c("mpg", "cyl", "hp", "gear", "wt")]

## Use Short but Meaningful Column Names
names(carData) <- c("MPG", "# of Cylinders", "Horsepower", "# of Gears", "Weight")

# Create the output data table
# Be sure to use the same name as you did in the UI
output$mtCars <- DT::renderDT(
  expr = carData,
  caption = "Motor Trend US Data, 1973-1974 Models", # Add a caption to your table
  style = "bootstrap4", # You must use this style
  rownames = TRUE,
  options = list( # You must use these options
    responsive = TRUE, # allows the data table to be mobile friendly
    scrollX = TRUE, # allows the user to scroll through a wide table
    columnDefs = list(  # These will set alignment of data values
      # Notice the use of ncol on your data frame; leave the 1 as is.
      list(className = 'dt-center', targets = 1:ncol(carData))
    )
  )
)
# [code omitted]
```

If you are making a Summary Data Table, you will need to follow the same process. If your data frame does not have row names, but instead a column with values acting as row names, you may replace the `rownames = TRUE` with `rownames = FALSE`; there should not be a column of sequential numbers on the left.

Column names __MUST__ be simple and *meaningful* to the user. To this end, you should rename any columns that might have poor choices for names, just as we have done with the `mtcars` data. This includes using Greek characters in isolation. You should not have any columns labeled \(\mu\) or \(\sigma\). Rather you need to use English words.

*Note: getting mathematical expressions to render properly in graphical environments in `R` is not as easy as in the paragraphs or headers of an app. Only certain graphing packages support limited mathematical expressions. The same is true for table generation packages.* 

Again, try to use tables as infrequently as possible. Poorly constructed tables can create accessibility issues causing screen readers to poorly communicate tables to your users. If you run into problems and/or have questions, __talk to Neil and Bob__. 

### Additional Table Examples

Neil built a [Data Table Examples app](https://rstudio-connect.tlt.psu.edu:3939/content/249) that you should reference when you're building data tables for display. (Note: you will need to connect to PSU's VPN in order to access this app.)

We're including some additional Summary Data Table examples. For these examples, I'm going to make use of the `palmerpenguins` package of data sets.

#### Summary Data Table of Descriptive Statistics

```{r dtSummary1Setup, echo=TRUE, eval=TRUE}
library(palmerpenguins)
library(psych)
library(DT)
library(tibble)

penStats <- psych::describeBy(
  x = penguins$body_mass_g,
  group = penguins$species,
  mat = TRUE, # Formats output appropriate for DT
  digits = 3 # sets the number of digits retained
)

# Picking which columns to keep
penStats <- penStats[, c("group1", "n", "mean", "sd", "median", "mad", "min", "max", "skew",
                         "kurtosis")]
# Make the group1 column the row names
penStats <- tibble::remove_rownames(penStats)
penStats <- tibble::column_to_rownames(penStats,
                          var = "group1")
# Improve column names
names(penStats) <- c("Count", "SAM (g/penguin)", "SASD (g)", "Median (g)", "MAD (g)", "Min (g)",
                     "Max (g)", "Sample Skewness (g^3)", "Sample Excess Kurtosis (g^4)")
```

```{r dtSummary1Shiny, echo=TRUE, eval=FALSE}
# Make the Table
output$penguinSummary <- DT::renderDT(
  expr = penStats,
  caption = "Descriptive Stats for Palmer Penguins", 
  style = "bootstrap4", 
  rownames = TRUE,
  autoHideNavigation = TRUE,
  options = list( 
    responsive = TRUE, 
    scrollX = TRUE,
    paging = FALSE, # Set to False for small tables
     columnDefs = list(
       list(className = 'dt-center',
            targets = 1:ncol(penStats))
    )
  )
)
```

```{r dtSummary1Target, echo=FALSE, eval=FALSE}
DT::datatable(
  data = penStats,
  caption = "Descriptive Stats for Palmer Penguins", 
  style = "bootstrap4", 
  rownames = TRUE,
  autoHideNavigation = TRUE,
  options = list( 
    responsive = TRUE, 
    scrollX = TRUE,
    paging = FALSE,
     columnDefs = list(
       list(className = 'dt-center',
            targets = 1:ncol(penStats))
    )
  )
)

```

#### Summary Data Table for Output Table

While this example is for an ANOVA table, you can build from this for other output tables. If you store the output of any call as an object, you can then use the structure function, `str` to investigate the output. Ultimately, you need something that is either a matrix or a data frame. 

```{r dtSummary2Setup, echo=TRUE, eval=TRUE}
library(palmerpenguins)
library(psych)
library(DT)
library(tibble)
library(rstatix)

# This bad practice but I'm going to pretend that all assumptions are met
penModel <- aov(body_mass_g ~ species*sex, data = penguins)

anovaPen <- round(anova(penModel), 3)
# Rounding to truncate decimals

```

```{r dtSummary2Shiny, echo=TRUE, eval=FALSE}
# Make the Table
output$penguinAnova <- DT::renderDT(
  expr = anovaPen,
  caption = "(Classical) ANOVA Table for Palmer Pengins", 
  style = "bootstrap4", 
  rownames = TRUE,
  options = list( 
    responsive = TRUE, 
    scrollX = TRUE,
    paging = FALSE, # Set to False for small tables
     columnDefs = list(
       list(className = 'dt-center',
            targets = 1:ncol(anovaPen))
    )
  )
)
```

```{r dtSummary2Target, echo=FALSE, eval=FALSE}
DT::datatable(
  data = anovaPen,
  caption = "(Classical) ANOVA Table for Palmer Penguins", 
  style = "bootstrap4", 
  rownames = TRUE,
  options = list( 
    responsive = TRUE, 
    scrollX = TRUE,
    paging = FALSE,
     columnDefs = list(
       list(className = 'dt-center',
            targets = 1:ncol(anovaPen))
    )
  )
)
```


## Alt Text, Again {#altText2}

Any graphical element you include in your App __MUST__ have an alternative (assistive) text description ("alt text"). This provides a short description of what is in the image or plot for users who are visual impaired. (Tables, when properly formatted will handle this automatically.)


Here are several resources worth checking out:

+ [WebAIM Alternative Text Guide](https://webaim.org/techniques/alttext/#basics)
+ [Penn State's Image ALT Text Page](https://accessibility.psu.edu/images/alttext/)
+ [W3C's ALT Text Decision Tree](https://www.w3.org/WAI/tutorials/images/decision-tree/)

### Adding Alt Text Graphs--`alt` Argument

With the release of `Shiny` version 1.6.0, the `renderPlot` function got a vital upgrade: there is now an `alt` argument that will allow you put alt text on your plots. The `alt` argument functions just like the matching argument in the `tags$img` call for static images.

Use this approach as your first choice method.

### Alt Text via ARIA

If a graph is particularly complicated or if you want to do some dynamic changes to the alt text, you might want to consider using [Accessible Rich Internet Applications (ARIA)](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA) to assist us in writing some labels that will stand in place of formal alt text. To do this, you will need to make use of the following code:

```{r plotsAltTextc, echo=TRUE, eval=FALSE}
# [code omitted]
# In the UI section, in the appropriate tabItem
plotOutput(outputId = plotID) # Look for lines like this 
# Code for adding the aria label
tags$script(HTML(
  "$(document).ready(function() {
  document.getElementById('plotId').setAttribute('aria-label',
  `General description of the plot`)
  })"
))
# [code omitted]
```

Important things to note:

1. Place the `tags$script(HTML(...))` code right after each instance of `plotOutput`.
2. Copy the above code as formatted
3. Change the two (2) pieces for each particular plot
    a. Replace `plotId` (keep the single quotation marks in the code)
    b. Replace `General description of the plot` (keep the single quotation marks in the code)


<!--chapter:end:13-rGraphics.Rmd-->

# (PART) Style Guide-Language {-}

# Wording {#wording}

This chapter focuses on the wording that we use within the BOAST Apps.

## General Guidelines
When writing the content for your App, you will want to keep in mind that our apps have students as the primary audience. Thus, we need to make sure that we use language that is appropriate. Seek to use complete sentences that convey what you intend. Have someone else take a look at your content and then tell you what they believe the text to be saying. If what they say is consistent with what you intended, great. If not, then you need to revise your text.

__DO NOT sacrifice clarity and precision/accuracy for
conciseness/brevity.__ While we don't necessarily want a wall of text, there should still be some text to assist the user.

Since these apps are for *teaching and learning*, we need to use language that is accurate and supports students in constructing productive meanings. This means that we need to avoid sloppy language, re-enforcing problematic conceptions, and supporting fallacies. For example,

+ Sloppy Language: Vagueness
    - BAD: "We want to explore how these averages differ."
    - NEUTRAL/FAIR: "We want to explore how these means differ."
    - GOOD: "We want to explore how the values of the *sample arithmetic mean* (*SAM*) varies between these groups."
+ Sloppy Language: Discussing values of statistics
    - BAD: The mean is 6.
    - GOOD: The value of the *sample arithematic mean* for this data is 6 units/object.
+ Problematic conceptions
    - BAD: Probability is the likelihood of an event in relation to all possible events.
    - GOOD: Probability is the long-run relative frequency for us seeing a particular data event given our assumptions. Likelihood is the long-run relative frequency of a set of assumptions being true given our collected data.
+ Fallacies
    - BAD: "We're 95% confident that the true population proportion is between 0.35 and 0.45."
    - GOOD: "If we were to repeat the entire study infinitely many times, then 95% of the time we will make an interval that captures the true population proportion."

## Popovers {#popovers}

The term "Popovers" refers to any number of different tools on websites that go by other names such as tool tips, rollovers, and hover text. In essence, this tool appears when the user places their cursor over (i.e., hover) or shifts the focus to a trigger object (typically user inputs or graphs). The text then pops up on the screen for the user to view. The function to create one of these in a Shiny app is `shinyBS::bsPopover`. While these can be powerful, they are often misused, leading to problems. For example, they can prevent the user from actually interacting with portions of your app when they appear. 

Popovers are meant to provide short, simple clarifications; quick annotations which enrich the content that is already present. This type of text is meant to be temporary, only appearing for as long as the user is hovering/focusing on the trigger object. Thus, if you are putting information that is critical for a person to successfully use your App in a popover, you are using popovers __INCORRECTLY__.

Here are few additional sources for reading about Popovers/Tooltips:

+ [Tooltips in UI Design](https://uxplanet.org/tooltips-in-ui-design-f63e117aa3d1)
+ [Tooltips: How to use this small but mighty UI pattern correctly](https://www.appcues.com/blog/tooltips)

Restrict any usage of a popover to something short and non-vital for your App's user. If you do choose to use a popover, you will need to format the popover correctly. Be sure that your function call includes values for the following arguments:

+ `id`: this needs to be the name of the object which will act as the trigger
+ `title`: this will be a string that appears across the top of your popover; use verbs with an understood "you" (e.g., "Investigate!", "Remember", etc.)
+ `content`: this will be the string that you want displayed; shorter is better.
+ `placement`: this will control where the popover appears. Choose the option (top, bottom, left, right) that works best for your space. Ensure that the placement does not cover any controls or other vital information.

The visual appearance of the popover will be control by the central BOAST CSS file.


## Dealing with Differing Vocabularies

One of the most challenging aspects of Wording is the fact that we have to deal with the Jingle/Jangle problem.

### The Jingle/Jangle Problem {#jingleJangle}
A term "jingles" when people use that term to refer to two (or more) different concepts. This is also know as a term having lexical ambiguity. For instance, *random* jingles when people use the term to convey haphazardness, arbitrariness, and/or an attribute of process. (Note: the only the third option is statistically valid.)

On the other hand, a set of 2+ different terms "jangle" when they refer to the same concept. A good/classical example of this is skewness. Some people talk about left/right skewness, others negative/positive skewness, and others will talk about long left/long right tails. Each of these pairs refer to the same core concept, but evoke different mental images.

### Option 0: Dictionary/Thesaurus
There are a variety of ways in which we could handle this approach. One thought is to build a Dictionary/Thesaurus for BOAST. While we could go down this route, this represents a considerable undertaking and might become a long term goal.

### Option 1: Hover Text {#hovertext}
The more immediate solution to differing vocabularies is for us to make use of hover text. This approach is appealing in that the user doesn't have to leave your App (like going to a dictionary/thesaurus) and the content of these tips is not critical to using your App. That is to say, the information is available for those who might need a quick reminder but does not take up permanent screen space.

To use this tool you'll need to make sure that you install and load the `tippy` package.

```{r, eval = FALSE}
install.packages("tippy")
```

Suppose that we want to add the hover text to the the word "positive" in the following sentence: 

> A positively skewed histogram will hoave potential outliers that are larger than the main modal clump(s).

We would need to do the following in our `app.R` (or `ui.R`) file:

```{r tippyEx1, echo=TRUE, eval=FALSE}
# Required Library
library(tippy)
# In UI Section
#[code omitted]
dashboardBody(
  #[code omitted]
  tabItem(
    tabName = "Overview",
    h1("Exploring Skewness"),
    p("A ",
      tippy::tippy(text = "positively skewed",
                   tooltip = "Sometimes called 'long right tail' or 'right skewed'",
                   arrow = TRUE, placement = "auto"),
      " histogram will have potential outliers that are larger than the main modal clump(s)."),
  #[code omitted]
)) 
```

There are several things to notice in the example:

1. The `tippy` call is part of the paragraph environment. If the text is going to be part of a list, then the `tippy` call should be part of a list item.
2. There are four (4) required arguments:
    a. `text`---the words that will be part of the page  
    b. `tooltip`---the words that will appear/disappear when the user hovers/focuses on the `text`
    c. `arrow = TRUE`---this creates an arrow from the `tooltip` to the `text`. Make sure to set this as `TRUE`
    d. `placement`---controls where the  the `tooltip` appears in relation to the `text`. While there are multiple values you could use here, we recommend using `auto` to allow the App to determine the best position. If you want to override this, then you should use values of `top`(shows above) or`bottom` (shows below).
3. Be sure to include spaces around text that appears before and after the `tippy` element.
4. Don't forget to put commas between the text and the `tippy` element. These won't appear in your App but allow R to see that there are multiple elements.

#### Choosing Terms-Jangle
If you are going to make use of hover text to combat a jangle problem, you are going to have to make a decision about what words/phrase will be part of the app (i.e., the `text`) and which words/phrases will be part of the hover text (i.e., the `tooltip`).

You should make this decision in conjunction with a faculty member. Our recommendations are to use the word or phrase which:

1. Best supports students in building productive meanings
2. Best supports students in seeing coherence between a variety of concepts

__Appealing to "tradition" or "this what most people do" IS NOT a valid justification.__ Again, these apps are to support students in building their understandings, we must do better.

In the `tippy` example above, the ordering of terms is:

1. positively skewed
2. long right tail
3. right skewed

This ordering reflects the ordering from most productive and coherent to least. "Positively skewed" works regardless of the orientation of the histogram (see [Figure \@ref(fig:skewEx1)](#fig:skewEx1)) as well as directly connecting to the statistic *sample skewness*. The later two only make sense in one orientation and do not connect to *sample skewness*. "Long right tail" is preferable to "right skewed" as this phrasing helps students avoid the common belief that the position term (right/left) is about where the bulk of the observations are.

```{r skewEx1, echo=FALSE, fig.width=3, fig.height=4, fig.cap="Same Data, Two Orientations", fig.show='hold', fig.align='center'}
par(mar = c(4, 4, 0.1, 0.1))
df1 <- data.frame(
    data = rexp(150, rate = 3)
)

ggplot2::ggplot(df1) +
    ggplot2::geom_histogram(mapping= ggplot2::aes(y = data), fill="red", binwidth = 0.5, col = "black", closed="left", boundary=0) +
    ggplot2::theme_bw() 

ggplot2::ggplot(df1) +
    ggplot2::geom_histogram(mapping = ggplot2::aes(x = data), fill = "blue", col="black", binwidth = 0.5, closed="left", boundary=0) +
    ggplot2::theme_bw()

```

#### Choosing Terms-Jingle
We will always use the statistical/probabilistic meaning for a term, never the colloquial/everyday/non-technical meaning(s).

### Option 2: Entry on the Prerequisites Tab/Page
Another option that you could do for both the jingle and jangle problems is to add an entry on the Prerequisites page. If you only have a jangle problem, you can use the [Hover Text](#hovertext) option.

Option 2 can be combined with Option 1.

## Footnotes
We recommend avoiding footnotes in favor of [Hover Text](#hovertext).

<!--chapter:end:14-wording.Rmd-->

# Documentation {#documentation}

These apps are the product of your hard work and are part of your academic record. Thus, you need to adhere to [Penn State's Academic Integrity Policy](https://undergrad.psu.edu/aappm/G-9-academic-integrity.html). This is especially important as we are making the apps available through a Creative Commons Attribution-NonCommerical-ShareAlike 4.0 International license ([CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)). If you have used code, pictures, data, or other materials from outside of the BOAST team, you __MUST__ give proper credit. These references will then be included on the App's References Tab.

## References

All apps will need a References Tab. This is where you'll place all references for your App, including R packages, borrowed code, data sources, images, etc. This in addition to the Acknowledgments.

__NOTE:__ listing something in the Acknowledgments DOES NOT waive this requirement.

We will make use of the [American Statistical Association's](https://amstat.tfjournals.com/asa-style-guide/) reference style. Please check with Neil, Matt, and Dennis for getting assistance. You can see this style in action, with the [Reference Tab](#refTab) example of [Chapter \@ref(layout)](#layout). Here is a starting code block for you to use:

```{r refTab1, echo=TRUE, eval=FALSE}
#[omitted code]
tabItem(
  tabName = "refs",
  withMathJax(),
  h2("References"),
  p(class = "hangingindent",
    "reference 1-alphabetically"),
  p(class = "hangingindent",
    "reference 2-alphabetically"),
  # Repeat as needed
)
```

Notice the use of `class = "hangingindent"`. You must include this with each reference as this will ensure the proper styling of your references.

If you need assistance with this section, please talk to Neil.

## Plagiarism

__You MAY NOT use blocks of code you've found online without giving proper attribution.__

There is a difference between looking at example code online to see how to do something and copying that code directly. The former is permissible, the later is plagiarism.

+ If you want to use someone else's code as is (without any changes), you should reach out to the author for permission first.
+ If you use someone else's code and make modifications, you need to give credit to where you got the code, and potentially ask for permission.

You will need to place citations in *__two__* places: in the References Tab and in your code. You might want to also consider adding an acknowledgement to the Overview tab.

### Reference Tab

Use the following format:

> Author. (Date), Title of program/source code, [type of code]. Available from  \< URL \>.

For example,

> Hatfield, N. J. (2017), First day activity, Netlogo. Available from <https://neilhatfield.github.io/statApps/Day1Activity.html>.

### In Code

Use the following format in your code to cite where you got the code from.

```{r citeCode, echo=TRUE, eval=FALSE}
#-------------------------------------------------------------------------------
#  Title: <title of program/source code>
#  Author: <author(s) names>
#  Date: <date>
#  Code version: <code version>
#  Availability: <where it's located>
#-------------------------------------------------------------------------------
# [borrowed code then follows]
# ...
# [last line of borrowed code]      
#End of <author>'s code----------------------------------------------------------
```

## `R` Packages
If you made use of any packages in `R`, then you will need to add these to the Reference tab. Fortunately, there is a built-in tool that will help you: the `citation` function. In R (RStudio) simply type `citation("packageName")` and you'll get the appropriate citation information for the package you used. For example, `citation("shinydashboard")` and `citation("plyr")` will give the information needed for the following citations:

> Chang, W. and Borges Ribeio, B. (2018), shinydashboard: Create dashboards with Shiny', R Package. Available from <https://CRAN.R-project.org/package=shinydashboard>

> Wickham, H. (2011), "The Split-apply-combine strategy for data analysis". <em>Journal of Statistical Software</em>, 40, pp.1-29. Available at <http://www.jstatsoft.org/v40/i01/>.

Notice, that the format of the R package will depend on whether there is an article published for the package. The `shinydashboard` package is not associated with an article while the `plyr` package is associated with Wickham's article.

## Graphics
Pictures, drawings, photographs, images, etc. are typically copyrighted. When you're selecting images, make sure that the images are Open Source/Copyright Free/Royalty Free/Public Domain. Additionally, include a reference to where the pictures came from in the Overview Page. The basic format to use is:

> LastName, First Initial. (Year), Title of artwork. Retrieved from \< URL \> (if available).

## Data
If you are using any data files, you need to attribute where those files are coming from in the References tab. You might also want to add an acknowledgment on the Overview tab. A suggested format to use is:

>Author/Rightsholder. (Year), Title of data set, [Description of form], Location: Name of producer.  

> Author/Rightsholder. (Year), Title of data set, [Description of form]. Available at <http://www.url.com>

If you (or someone else) had to sign some type of agreement to access the data, we must examine the agreement before you make your App publicly accessible. Just because you got access to the data does not mean you have the right to share the data.


<!--chapter:end:15-documentation.Rmd-->

# (PART) Accessibility and Mobile Devices {-}

# Accessibility {#accessibility}

We need to make sure that our Apps are accessible. If you have been adhering to the style guide, your App should be in a decent position. When you're ready to test the accessibility of your App, you'll need to deploy the App to a sever and then use the [WAVE Web Accessibility Evaluation Tool](https://wave.webaim.org/). Enter the URL of your App in the noted box to run an evaluation. See what accessibility issues your App has and then address them.

If you are testing an app you've deployed to the TLT Server, the PSU VPN will block the WAVE tool from scanning. However, you can use the [WAVE Browser Extensions](https://wave.webaim.org/extension/) to test your app. After installing the browser extension (and connecting to the VPN), open your app in a new browser tab and then activate the browser extensions. Look through to see what errors and warnings get listed. Deactivate the extension, and navigate to a different page of your app and then re-activate the WAVE extension. Similarly, you'll want to make sure that any objects that might initially be hidden are actually showing before you activate the WAVE browser extension. The nature of Shiny apps can impede the WAVE tool, thus you'll want to check each page of your app separately.



__See also:__

  - [Accessibility and Usability at Penn State](https://accessibility.psu.edu/)
  - [Accessibility Statement](https://www.psu.edu/accessibilitystatement)
  - [How to Meet Web Content Accessibility Guidelines](https://www.w3.org/WAI/WCAG21/quickref/)
  - [7 Things Every Designer Needs to Know about Accessibility](https://medium.com/salesforce-ux/7-things-every-designer-needs-to-know-about-accessibility-64f105f0881b)

## Making Your App Accessible

The best way that you can make your App accessible is to adhere to this Style Guide as closely as possible. Sadly, the Shiny framework is woefully behind the times for making truly accessible apps. We have tried to strike a balance so that you won't be inundated with significant burdens for accessibility. By following this Style Guide, you'll place your App in the best position possible. 

As we figure out and develop new tools to help you improve the accessibility of your App, we might ask you to return to your App and make updates. 

## Checking Accessibility

There are a couple of different phases to testing an app for Accessibility: Testing, Reading a Report, and Addressing Issues.

### Testing Accessibility

We highly recommend using the [WAVE Web Accessibility Evaluation Tool](https://wave.webaim.org/). If you use Firefox or Chrome, we recommend that you install the [WAVE Browser Extension](https://wave.webaim.org/extension/) as this will give you a quick way to test your App's accessibility.

Depending on whether you're checking an app that is already in BOAST or a revision/new app, you'll need to access the WAVE tool differently.

#### Testing an App in BOAST

To check an App that is currently linked in BOAST:

1. Go to [WAVE Web Accessibility Evaluation Tool](https://wave.webaim.org/)
2. In a new tab, launch the app from BOAST
3. Copy the app's URL from the address bar of your browser
4. Paste the URL in the Web page address field of WAVE

#### Testing a Revision/New App

To check an App that you are currently revising and/or developing (i.e., the App has *not* been formally added to BOAST):

1. Make sure you install the [WAVE Browser Extension](https://wave.webaim.org/extension/) for Firefox or Chrome.
2. Click the Run App button in RStudio
3. In the resulting window, click the Open in Browser button located along the top edge
4. Activate the WAVE Browser Extension

To help make the report more friendly with your browser, we also recommend you install the [Stylus Add-on for Firefox](https://addons.mozilla.org/en-US/firefox/addon/styl-us/) or the [Stylus Add-on for Chrome](https://chrome.google.com/webstore/detail/stylus/clngdbkpkpeebahjckkjfobafhncgmne?hl=en). Once you've installed Stylus, you'll want to 

1. Create a new Style in Stylus
2. Add the following code:
    ```{css stylusCode, echo=TRUE, eval=FALSE}
    body.ng-scope {
      position: relative
    }
    ```
3. Save and close the Stylus tab

This will move the the WAVE summary bar further to the left. If you have questions, please reach out to Neil and Bob.

### Reading a WAVE Report

```{r waveDescStat, fig.align='center', echo=FALSE, fig.cap="WAVE Report for Descriptive Statistics App"}
knitr::include_graphics("images/descStatOverview.png")
```

[Figure \@ref(fig:waveDescStat)](#fig:waveDescStat) shows the WAVE report for the Descriptive Statistics App. There are 54 errors including missing alternative text, empty headings. There are also 8 contrast errors, 14 alerts (skipping heading levels),

```{r waveOverfit, fig.align='center', echo=FALSE, fig.cap="WAVE Report for Overfitting App"}
knitr::include_graphics("images/overfitPrereq.png")
```

While there are fewer errors for the Overfitting App ([Figure \@ref(fig:waveOverfit)](#waveOverfit)), there are a lot of alerts on this app including skipping heading levels and small text.

The six categories of items in the WAVE report reflect the areas in which you're going to work on identifying issues. The two most critical issues are Errors and Contrast Errors. While the goal would be to have 0 for both, we do anticipate a few issues that we will have to leave unresolved. The third category that you need to attend to is the Alerts group. Again, we would like this number to be 0. The Features, Structural Elements, and ARIA categories are informational and you don't necessarily need to worry about them (they don't signify problems).

After running WAVE and getting the report, click on the View details button to see the list of all items found to see details. Additionally, you'll be able to click on items in the Details to see which things in your App are being flagged.

### Addressing Issues

By looking at the details you'll be able to identify what issues you need to address. We fully expect that some issues (e.g., Error: missing alt text, Alert: missing first level heading) are things that you can directly fix. However, we also anticipate that there are some issues that you might not be able to fix (e.g., Error: Document language missing) without assistance. 

We recommend that you document all errors and alerts that you've yet to resolve with you make your Pull Request. The decision about whether to leave an Accessibility Error or Alert alone/un-addressed has to be made by a faculty member (e.g., Neil, Dennis, Matt, or Bob), not any student.

By using the `boastApp` function and adhering to this Style Guide, your App should be in a good initial position. After running your App through WAVE, we can work with you address any changes that might be necessary.

<!--chapter:end:16-accessibility.Rmd-->

# Mobile Friendliness {#mobile}

We want our apps to work well with mobile devices. Thus, when you get to the point where the majority of bugs have been fixed, you need to check how mobile friendly your App is. If you have used `boastApp` and/or the `boast.CSS` file, along with the practices laid out earlier, then you should be well on your way to being mobile friendly.

You can check your App in two ways:

1.  Test your App out on a variety of mobile devices.
2.  Make use of a browser's ability to mimic devices. To do this, launch your App in a browser, then enable one of the following:
      - [Chrome: Device Mode](https://developers.google.com/web/tools/chrome-devtools/device-mode/#viewport)
      - [Firefox: Responsive Design Mode](https://developer.mozilla.org/en-US/docs/Tools/Responsive_Design_Mode)
      - [Microsoft Edge: Device Emulation](https://docs.microsoft.com/en-us/microsoft-edge/devtools-guide/emulation)
      - [Safari: Responsive Design Mode](https://support.apple.com/en-gb/guide/safari-developer/dev84bd42758/mac)

Look for any issues that you might be able to address before you hand off your App for others to play around with. Assign a __Mobile Friendliness Rating__ to your App on a scale from 1 to 5.

1.  Not functional
2.  Functional  Very awkward
3.  Functional  Okay if no big screen available (multiple issues)
4.  Usable in a small class setting (single issue)
5.  Readily usable

<!--chapter:end:17-mobile.Rmd-->

# (PART) Final Thoughts {-}

# Additional Tools {#addTools}

Here are a few additional tools that can help you with App development:

  - [lintr](https://github.com/jimhester/lintr) - Checks adherence to a
    given style, syntax errors, and possible semantic issues.
  - [styler](https://www.tidyverse.org/articles/2017/12/styler-1.0.0/) -
    Format R code according to a style guide.
  - [funchir](https://github.com/MichaelChirico/funchir) - stale package
    check
    
**R Code**
```{r, eval = FALSE}
install.packages(c("funchir", "lintr", "styler"))
```

<!--chapter:end:18-additionalTools.Rmd-->

